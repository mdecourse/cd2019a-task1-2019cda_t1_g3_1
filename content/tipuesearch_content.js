var tipuesearch = {"pages": [{'title': '組員', 'text': '40623109 \n 40623112 \n 40623118 \n 40623125 \n 40623127 \n 40623128 \n 40623135 \n 40623141 \n 40623156 \n', 'tags': '', 'url': '組員.html'}, {'title': '手足球', 'text': '圖檔位置: \n https://cad.onshape.com/documents/0bfaa15bd19b1324aaa7e507/w/04eb23a61d6467f8c87c3a8e/e/ecd14e928fc285a5eb479e63 \n 藉由 建立手足球系統來更加熟悉vrep的各項設定與操作 \n', 'tags': '', 'url': '手足球.html'}, {'title': '足球自動回擊', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python原始碼: \n import vrep\nfrom time import sleep\nimport sys, math\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90      #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef getballposition():\n    errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    vv =position_D[1] - position_P[1]\n    vvv =position_D[2] - position_P[2]\n    while (n == 1):\n        \n        if vv <= 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n            \n        elif vv <= 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,vv,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop()\n\n\n\n\n\n \n ＿ \n', 'tags': '', 'url': '足球自動回擊.html'}, {'title': '手足球雙人對打', 'text': '\n vrep檔案位置: tablefootball.ttt \n python控制程式 \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90    \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        try:\n            if keyboard.is_pressed(\'v\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'b\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'z\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'x\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'c\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            \n            elif keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'y\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            else:\n                pass\n        except:\n            break \n        MMMB = Bv*2\n        MMMR = Rv*2\n    vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球雙人對打.html'}, {'title': '手足球電腦對電腦', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python控制程式: \n import vrep\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 45     #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    #for i in range(steps):\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[0] - position_RR[0]\n    while (n == 1):\n        \n        if Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        else:\n                pass\n        MMMB = Bv*1.2 \n        MMMR = Rv*1.2\n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n        vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n        #print(BBv)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球電腦對電腦.html'}, {'title': '手足球手控與電腦對打', 'text': '\n vrep檔案位置: tablefootball.ttt \n python原始碼: \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90    \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[2]-position_S[2]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        if Bv <= 0 and BBv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n         \n        elif Bv > 0 and BBv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n             \n        elif Bv <= 0 and BBv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n         \n        elif Bv > 0 and BBv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n        \n        try:\n            if keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'y\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            else:\n                pass\n        except:\n            break \n            \n        \n        MMMB = Bv*2\n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球手控與電腦對打.html'}, {'title': '手足球問題與解決方案', 'text': '手足球問題一 \n 如何知道目前的球的位置? \n 解決方法: \n 運用指令 \n number returnCode,number parentObjectHandle=vrep.simxGetObjectParent(number clientID,number objectHandle,number operationMode) \n 來得到目前座標 \n \n 手足球問題二 \n 如何讓回擊的桿子偵測球的位置進行移動? \n 解決方法: \n 利用指令得到球與桿子的y方向座標之後 \n 利用相減所得到的值可以知道球在桿子的左邊或是右邊 \n \n 手足球問題三 \n 直接給定桿子橫向移動的速度為0.5m/s \n 會讓他產生速度從0瞬間變 0.5m/s 的現象 \n 解決方法: \n 把給定的速度更改為桿子與球座標的差值 \n \n', 'tags': '', 'url': '手足球問題與解決方案.html'}, {'title': '參考資料', 'text': '\n', 'tags': '', 'url': '參考資料.html'}, {'title': '課程內容整理', 'text': '', 'tags': '', 'url': '課程內容整理.html'}, {'title': '隨身系統', 'text': '藉由自行製作隨身系統，來了解隨身系統的運作方式，以便了解工具的使用與設定，並可以量身打造所需的隨身系統。 \n 創建資料夾 \n 創建一個放置可攜檔案的資料夾 \n 並在裡面 創建一個data資料夾用來連結y槽 \n SciTE \n 安裝SciTE至data資料夾中 \n 使用windos的 \xa0 full download版本 \n SciTE Download: https://www.scintilla.org/SciTEDownload.html \n 打開SciTE後 \n 開啟設定檔案 \n \n 利用ctrl+f找到code.page並改為下圖所示 \n \n 安裝 python 進可攜系統 \n 安裝時選取自訂義安裝 \n \n 勾選所需要的項目 \n \n \n 設定安裝位置 \n \n 利用 HxD 二位元編輯器設定C:\\p37\\Scripts\\pip.exe \n 使用ctrl+f功能尋找c :\\p37並改為y:\\p37 \n 如紅字處 \n \n \n 更改完成後就可以把整個p37資料夾移至data資料夾 \n start.bat \n 利用安裝的SciTE製作start.bat檔案 \n \n stop.bat \n 利用安裝的SciTE製作stop.bat檔案 \n \n Kdiff3 \n 在製作過程中想要快速了解兩個檔案之間的差異可以使用Kdiff3來快速比對出不一樣的地方。 \n Kdiff3:  http://kdiff3.sourceforge.net/ \n', 'tags': '', 'url': '隨身系統.html'}, {'title': 'Git - ungit', 'text': '使用圖形化介面讓使用者更加了解目前所在的分支與倉儲狀況 \n 如何安裝 \n 參考連結 http://mde.tw/wcm2019/content/%E5%AF%A6%E7%BF%92%E9%A0%85%E7%9B%AE%E4%BA%8C.html \n 至上方連結處下載 \xa0 nodejs_with_ungit.7z \n 下載完成後解壓縮到隨身系統資料夾的data中 \n 並在start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n set path8=%Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm; \n %path8%; \n 如下圖 \n \n \n 之後在中空白的SciTE中輸入 \n ungit --launchBrowser=0 --launchCommand "C:\\PROGRA~2\\Google\\Chrome\\Application\\chrome.exe\xa0 %%U" \n 存檔至Data中並命名為kungit.bat', 'tags': '', 'url': 'Git - ungit.html'}, {'title': 'ssh金鑰', 'text': '參考連結: https://2019wcm.blogspot.com/2019/03/github-github-pages.html \n 關閉跳出式登入窗 \n 首先 使用 git config --edit --system \n 叫出vi 編輯器,編輯git的設定檔案 \n 使用按鍵H,J,K,L控制上下左右 \n 案a進入編輯模式 \n 編輯模式最底下會顯示 \n -- INSERT -- \n 就可以按BACKSPACE刪除最後一行如下圖 \n \n 刪除後按ESC鍵離開編輯模式 \n 再輸入冒號後，再輸入wq存檔並關閉。 \n 如果要直接離開則輸入exit \n 製作金鑰 \n 在 可攜系統的命令列視窗輸入sh或者是sh_yen(可至y:\\git\\bin中確認) \n 執行 Git 的 shell \n 並輸入 \n ssh-keygen -t rsa -b 4096 -C "This is my key" \n 將會建立Private 與 Public 金鑰至y:\\home\\.ssh\\id_rsa與id_rsa.pub \n 將 id_rsa.pub 的內容複製轉貼至Github 帳號的settings如下圖位置 \n \n \n \n 在SSH and GPG keys的SSH Key新建並貼上複製內容 \n 利用SSH提交推送 \n 首先要確認倉儲是以SSH的方式clone的 \n 利用以下指令clone或 \n git clone\xa0 git@github.com:倉儲擁有者/ 倉儲名 \n 或是直接利用SciTE開啟倉儲的.git檔案裡面的config \n 把url = https://github.com/ 倉儲擁有者/ 倉儲名 \n 改成url = git@github.com: 倉儲擁有者/ 倉儲名 \n 之後直接提交推送就可以不用打帳號密碼了 \n', 'tags': '', 'url': 'ssh金鑰.html'}, {'title': 'git', 'text': 'Plumbing and Porcelain \n Plumbing and Porcelain \n \n \n \n Git Objects \n Git Objects \n cat -file 從Git 取回資料 \n update - ref更新引用 \n Git References \n Git References \n 如何知道最後一次提交？ : \n 執行\xa0 git branch\xa0 \n $ cat .git/HEAD  \n ref: refs/heads/master \n 執行 git checkout test \n $ cat .git/HEAD  \n ref: refs/heads/test \n 手動編輯此文件，但同樣可以執行更安全的命令: \n 執行symbolic-ref \n $ git symbolic-ref HEAD  \n refs/heads/master \n 設置HEAD: \n $ git symbolic-ref HEAD  refs/heads/test  \n $ cat .git/HEAD  \n ref: refs/heads/test \n \n \n \n Packfiles \n Packfiles 使用 git cat-file 命令查看這個文件大小 \n $ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 22044 \n 使用git gc打包文件 \n $ git gc Counting objects: 18, done. Delta compression using up to 8 threads. Compressing objects: 100% (14/14), done. Writing objects: 100% (18/18), done. Total 18 (delta 3), reused 0 (delta 0) \n \n The Refspec \n The Refspec \n .git / config文件中添加遠端origin的名稱，遠程存儲庫的URL以及用於獲取的refspec \n [remote "origin"] url = https://github.com/schacon/simplegit-progit fetch = +refs/heads/ :refs/remotes/origin/ 如果想一次性執行某些操作，也可以在命令行中指定refspec \n $ git fetch origin master:refs/remotes/origin/mymaster 指定多個refspec \n $ git fetch origin master:refs/remotes/origin/mymaster \\\n\t topic:refs/remotes/origin/topic\nFrom git@github.com:schacon/simplegit\n ! [rejected]        master     -> origin/mymaster  (non fast forward)\n * [new branch]      topic      -> origin/topic 刪除 refspec git push origin :topic git push origin -- delete topic \n Transfer Protocols \n Transfer Protocols \n Transfer Protocols--傳輸協議 \n Git可以透過兩種主要方式在兩個倉儲之間傳輸數據：“啞吧”協議與“智能”協議。 本章重點著重於介紹這兩個主要協議的運作方式。 \n The Dumb Protocol--啞巴協議 \n 該協議稱為“啞巴協議”，是因為它在傳輸過程中不需要服務端的Git特定代碼;\xa0獲取過程是一系列HTTP\xa0 GET 請求，使用者可以自由的呈現Git倉儲的安排。 \n \n Maintenance and Data Recovery \n Maintenance and Data Recovery \n 本章重點在介紹Git內部的維護和數據的恢復，有時Git會自動執行一個名為“auto\xa0 gc ”的指令，大多數情況下，指令不執行操作，但如果有過多的packfiles，則Git會執行git gc的指令，指令會刪除不必要的文件。 \n 當需要恢復檔案時 可使用git long和git master兩個指令來進行恢復。 \n \n Environment Variables \n Environment Variables \n Git在 bash shell中運行，並使用許多shell環境變量來確定它的行為方式。 \n GIT_EXEC_PATH： 可透過運行檢查當前設置 git --exec-path 。 \n HOME： 它是Git查找全局配置文件的地方。 \n GIT_CONFIG_NOSYSTEM： 如果您的系統配置干擾了您的指令，但是您無權更改或刪除它，這將非常有用。 \n 設置提交者的名字:\xa0 GIT_COMMITTER_NAME \n \n “提交者”字段的電子郵件地址:\xa0 GIT_COMMITTER_EMAIL \xa0 \n \n \n \n 用於“提交者”字段中的日期:\xa0 GIT_COMMITTER_DATE \n \n \n Summy \n Summary \n 功能很強的系統工具-Git \n 可以輕鬆使用它作為VCS。本章介紹了許多管道指令 - 這些指令使用戶在使用上更家簡單。 \n A3 \n git config \n 該 git config 命令幾乎已在本書的每一章中使用 \n 在初次設置Git中， 我們在開始使用Git之前用它來指定我們的名字，電子郵件地址和編輯器首選項 \n git init \n 我們使用此命令在“將空白倉儲放到 服務器上”中為服務器創建一個空的空白倉儲。 gitstatus \n 該 git status 命令將顯示工作目錄和暫存區域中文件的不同狀態。 哪些文件已修改和未分階段，哪些文件已暫存但尚未提交。 在它的正常形式中，它還將向您展示如何在這些階段之間移動文件的一些基本提示。 \n git diff \n 當您想要查看任意兩棵樹之間的差異時，將使用該命令。 這可能是您的工作環境和臨時區域（單獨 git diff ），暫存區域和上次提交（ git diff --staged ）之間，或兩個提交（ git diff master branchB ） 之間的差異 。 \n git difftool \n 只是啟動一個外部工具，以顯示兩棵樹之間的區別，以防您想使用內置 git diff 命令 之外的其他內容 。 \n \n git reset 主要用於撤消操作，您可以通過動詞來判斷。它在 HEAD 指針 周圍移動 並可選地更改 index 或暫存區域，如果使用，還可以選擇更改工作目錄 。 如果使用不當，此最終選項可能會導致此命令丟失，因此請確保在使用之前了解它。 \n git rm \n 用於從登台區域和Git的工作目錄中刪除文件。它類似於 git add 它為下一次提交分階段刪除文件。 \n git mv \n 是一個簡單的便捷命令，用於移動文件，然後 git add 在新文件和 git rm 舊文件上運行。 我們只 在移動檔案中 簡要提一下這個命令 。 \n git mergetool \n \n \n \n 該 git mergetool 命令只是啟動一個外部合併幫助程序，以防您在Git中遇到合併題。 \n \n \n \n git stash \n \n 用於臨時存儲未提交的工作，以便清除工作目錄，而無需在分支上提交未完成的工作。 這基本上完全涵蓋在 Stashing和Cleaning中。 \n \n \n \n \n A3-1 \n git tag \n \n 該 git tag 命令用於為代碼歷史記錄中的特定點提供永久書籤。 通常，這用於發布容。 \n \n \n \n \n git fetch \n \n \n \n 該 git fetch 命令與遠程存儲庫通信，並獲取該存儲庫中當前不存在的所有信息，並將其存儲在本地數據庫中。 \n \n \n \n \n \n git remote \n \n \n \n 該 git remote 命令是用於記錄遠程存儲庫的管理工具。它允許您將長URL保存，例如“origin”，這樣您就不必一直輸出它們。您可以使用其中的幾個，該 git remote 命令用於添加，更改和刪除它們。 \n \n \n \n \n \n git archive \n \n \n \n 該 git archive 命令用於創建項目特定快照的存檔文件。 我們 git archive 用來創建一個項目的tarball，用於在 準備釋出一個版本中 進行共享。 \n \n \n \n \n \n git submodule \n \n \n \n 該 git submodule 命令用於管理正常存儲庫中的外部存儲庫。這可能適用於庫或其他類型的共享資源。該 submodule 命令具有若干子命令（ add ， update ， sync ，等），用於管理這些資源。 \n \n \n \n \n git show \n \n \n \n \n 該 git show 命令可以以簡單且可讀的方式顯示Git對象。 通常，您可以使用它來顯示有關標記或提交的信息。 \n \n \n \n \n git shortlog \n \n \n \n 該 git shortlog 命令用於匯總輸出 git log 。該命令將採用許多相同的選項， git log 但它不會列出所有提交，而是顯示按作者分組的提交的摘要。 \n \n \n \n \n \n 8.1 \n (有工具可以解決圖形衝突 ) \n 外部合併和差異工具 \n \n 您可以設置一個外部工具，來自動解決圖形衝突，而不必手動解決。 \n 強制視覺合併工具 " (P4Merge)  來執行差異和合併解析度 ,  因為它是一個不錯的圖形工具 ,  並且是免費的。 \n 8.2 \n Git 屬性資料還允許您在匯出專案存檔時執行一些有趣的操作。 \n \xa0 \n 您可以告訴  Git  在生成存檔時不要匯出某些檔或目錄。如果有一個子目錄或檔不希望包含在存檔檔中 ,  但您確實希望簽入專案 ,  則可以通過export-ignore確定這些檔。 \n 例如 ,  假設您在test/子目錄中有一些測試檔案 ,  而將它們包含在專案的  tarball  匯出中是沒有意義的。您可以將以下行添加到  Git  屬性檔中 : \n test/ export-ignore \n 合併策略 \n 您還可以使用  Git  屬性告訴  Git  對專案中的特定檔使用不同的合併策略。一個非常有用的選擇是告訴  Git  不要嘗試合併特定的檔時 ,  他們有衝突 ,  而是使用你的一方合併超過別人的。 \n 如果專案中的分支存在分歧或是專用的 ,  但您希望能夠將更改合併回其中 ,  並且希望忽略某些檔 ,  這將很有説明。假設您有一個名為database.xml\xa0" 的資料庫設置檔 ,  該檔在兩個分支中是不同的 ,  並且您希望在不弄亂資料庫檔案的情況下合併到其他分支中。 \n 8.3 \n 整理 自訂 Git Hooks \n 教你一些鉤子的用法並告訴妳這些能尬麻 ?  使用鉤子來檢查提交消息是否符合所需的模式等等 ….. \n 前 4 種掛鉤與提交過程有關 \n 新興工作流程掛鉤 \n 電子郵件工作流程掛鉤 \n 其他用戶端掛鉤 \n 伺服器端掛鉤 \n \n \n 注意 :  此腳本無法停止推送過程 ,  但用戶端在完成之前不會斷開連接 ,  因此 ,  如果您嘗試執行任何可能需要很長時間的操作 ,  請務必小心。 \n 8.4 \n \n 本章要用你所學過的知識來建一個 git 工作流，並將構建用戶端腳本 ,  以説明開發人員知道他們的推送是否會被拒絕 ,  以及實際強制實施策略的伺服器腳本。 \n \n 7.2 \n 交互式暫存 運行git add時使用-i或者--interactive選項，Git將會進入一個交互式終端模式 $ git add -i 暫存與取消暫存文件 在如果What now>提示符後鍵入2或u，腳本將會提示想要暫存哪個文件 Update>> 1,2 \n 如果在Update>>提示符後不輸入任何東西並直接按回車，Git將會暫存之前選擇的文件 要取消暫存TODO文件，使用3或r（撤消）選項 \n 7.1\xa0工具 - 選擇修訂版本 \n 如何獲取單個與區間提交的多種方法。 簡短的 SHA-1 Git 十分智能，你只需要提供SHA-1 的前幾個字符就可以獲得對應的那次提交，當然你提供的SHA-1 字符數量不得少於4 個，並且沒有歧義——也就是說，當前倉庫中只有一個對像以這段SHA-1 開頭。 假設這個提交是 1c002dd....，如果你想 git show 這個提交，下面的命令是等價的（假設簡短的版本沒有歧義）： $ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b $ git show 1c002dd4b536e7479f $ git show 1c002d 分支引用 你想要查看一個分支的最後一次提交的對象，假設 topic1 分支指ca82a6d ，那麼以下的命令是等價的: $ git show ca82a6dff817ec66f44342007202690a93763949 $ git show topic1 rev-parse 的 Git 探測工具 想知道某個分支指向哪個特定的 SHA-1，或者看任何一個例子中被簡寫的 SHA-1 引用日誌 你可以使用\xa0git reflog\xa0来查看引用日誌 查看你的master分支在昨天的時候指向了哪個提交 $ git show master@{yesterday} 運行可以git log -g來查看類似於git log輸出格式的引用日誌信息 祖先引用 你可以使用HEAD^來查看上一個提交，也就是“HEAD的父提交”： $ git show HEAD^ 後面添加一個數字 - 例如d921970^2代表“d921970的第二父提交”這個語法只適用於合併（merge）的提交 $ git show d921970^2 另一種指明祖先提交的方法是~，因此HEAD~和HEAD^是等價的 提交區間 $ git log master..experiment 查看在master分支中而不在experiment分支中的提交 $ git log experiment..master 多點  下列3個命令是等價的： $ git log refA..refB $ git log ^refA refB $ git log refB --not refA 所有被refA或refB包含的但是不被refC包含的提交 $ git log refA refB ^refC $ git log refA refB --not refC 三點 master或者experiment中所有遊戲的但不是兩者教育學習語言文字的提交 $ git log master...experiment \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'git.html'}, {'title': 'V-rep', 'text': 'Proximity sensor \n 添加 接近傳感 器\xa0 proximity sensor \n Menu bar --> Add --> Proximity sensor --> Cone type \n \n 在\xa0 orientation dialog \xa0對話框中 \n 沿y軸和z軸旋轉90度\xa0 \xa0點擊Rotation Selection \n \n 在\xa0 position dialog \xa0對話框中 \n x方向設置0.1\xa0 z方向設置0.12 \n \n 修改距離傳感器的參數Show volume parameter \n Offset \xa0 \xa00.005, \xa0 Angle \xa0 \xa030  \xa0 Range \xa0 \xa00.15 \n Show detection parameter中將Don’t\xa0 allow detection ifdistance smaller than取消 \n 最後將傳感器連接到機器人的身體 \n \n Vision sensor \n 添加視覺傳感器\xa0 vision sensor \n Menu bar-->Add-->Vision sensor-->Perspective type \n 將視覺傳感器和距離傳感器放置一起且方向一致 \n 1. 在視覺傳感器的屬性欄中配置Far clipping plane 爲1 \n \xa0 \xa0 Resolution x 和y 設爲256和256 \n 2. 點擊show filter dialog\xa0 \n \n 3. 選擇Edget detection on work image \n \xa0 \xa0然後點擊Add filter \n 4. 閾值設置爲0.2 點選OK \n \n Floating view上右鍵 View-->Associate simulation with selected vision sensor \n \n 就可以看到視覺感測器的畫面 \n \n bubbleRob腳本 \n 選擇對象BubbleRob--->右鍵選擇Add-->Associate child script-->Non threaded \n 腳本文件語言爲lua語言 \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n bubbleRob \n 成品圖 \n \n', 'tags': '', 'url': 'V-rep.html'}, {'title': 'Onshape', 'text': '手足球製作 \n 足球員 \n \n 場地 \n \n 手把 \n \n 組合圖 \n \n 40623118：製作手把與進行組合圖組裝 \n 40623141：製作手足球員與場地 \n 組合圖連結 \n', 'tags': '', 'url': 'Onshape.html'}, {'title': '問題與討論', 'text': '', 'tags': '', 'url': '問題與討論.html'}, {'title': 'ungit', 'text': '問題-無法取得使用者資料-已解決 \n 當使用ungit提交推送時，出現如下圖的錯誤內容 \n \n 解決方法: \n 至啟動隨身系統的start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n 使ungit能找到 y:\\home中的使用者目錄 \n', 'tags': '', 'url': 'ungit.html'}, {'title': 'ShareX', 'text': "遇到以下問題 \n ffmpeg version N-92972-g301cee61fa Copyright (c) 2000-2019 the FFmpeg developers\xa0 \xa0 \n built with gcc 8.2.1 (GCC) 20181201\xa0 \n  \xa0configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-amf --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt\xa0 \xa0 \n libavutil\xa0 \xa0 \xa0  56. 25.100 / 56. 25.100\xa0 \xa0 \n libavcodec\xa0 \xa0 \xa058. 43.101 / 58. 43.101\xa0 \xa0 \n libavformat\xa0 \xa0 58. 25.100 / 58. 25.100\xa0  \n libavdevice\xa0 \xa0 58.\xa0 6.101 / 58.\xa0 6.101\xa0 \n libavfilter\xa0 \xa0 \xa07. 48.100 /\xa0 7. 48.100\xa0 \xa0 \n libswscale\xa0 \xa0 \xa0 5.\xa0 4.100 /\xa0 5.\xa0 4.100\xa0 \xa0 \n libswresample\xa0 \xa03.\xa0 4.100 /\xa0 3.\xa0 4.100\xa0 \xa0 \n libpostproc\xa0 \xa0 55.\xa0 4.100 / 55.\xa0 4.100  \n [gdigrab @ 00000298ebd8ca40] Capturing whole desktop as 1680x1050x32 at (0,0) [gdigrab @ 00000298ebd8ca40] Stream #0: not enough frames to estimate rate; consider increasing probesize Input #0, gdigrab, from 'desktop':\xa0 \xa0Duration: N/A, start: 1554687275.611611, bitrate: 1693452 kb/s\xa0 \xa0 \xa0 \n Stream #0:0: Video: bmp, bgra, 1680x1050, 1693452 kb/s, 30 fps, 1000k tbr, 1000k tbn, 1000k tbc [dshow @ 00000298ebd90900] Could not enumerate audio only devices (or none found). [dshow @ 00000298ebd90900] Searching for audio device within video devices for 麥克風 (Realtek High Definition Au [dshow @ 00000298ebd90900] Could not enumerate audio only devices (or none found).  \n audio=麥克風 (Realtek High Definition Au: I/O error \n \n 解決辦法 \n google 搜尋 ShareX FFMPEG Error \n Task settings>Scren recorder>Screen recording options \n \n \n 按Install recorder devices來安裝，並在Audio source選擇None \n \n \n", 'tags': '', 'url': 'ShareX.html'}, {'title': '組員操作影片', 'text': '', 'tags': '', 'url': '組員操作影片.html'}, {'title': '如何製作可攜系統', 'text': '40623105 \n \n 40623109 \n \n 40623118 \n \n 40623141 \n \n 40623156 \n \n', 'tags': '', 'url': '如何製作可攜系統.html'}, {'title': 'v-rep tutorial', 'text': '40623105 \n \n 40623109 \n \n 操作檔案： bubbleRob.ttt \n 40623118 \n \n 40623127 \n \n 40623135 \n \n \n', 'tags': '', 'url': 'v-rep tutorial.html'}, {'title': 'Git教材', 'text': '', 'tags': '', 'url': 'Git教材.html'}, {'title': '伺服器上的Git', 'text': 'Git可以使用四種主要協議來傳輸數據： \n Local protocols、HTTP、Secure Shell（SSH）和Git。 \n 通過上方多種方式啟動並運行遠程Git存儲庫，以便您可以與其他人協作或共享您的工作。 \n 運行自己的服務器可以為您提供很多控制，並允許您在自己的防火牆內運行服務器，但是這樣的服務器通常需要相當多的時間來設置和維護。 \n 通訊協定種類 \n \n Local protocols \n 優點: \n 1.可以直接將存儲庫副本粘貼到每個人都具有共享存取權限的位置，並像設置任何其他共享目錄一樣設置讀/寫權限。 \n 2.運用這些指令(git pull /home/john/project等) ，通常會更簡單地使他們推送到遠端，並且您也方便拉取。 缺點: \n 1.共享存取通常更難以從多個位置進行設置和存取。 \n 2.若在家使用筆電的話，需額外安裝遠端系統，否則會相對於基本網路存取還要來得困難與慢上許多。 \n 3.每個用戶都具有對“遠程”目錄的完全要訪問權限，並且沒有任何東西阻止他們更改或刪除內部Git文件並破壞存儲庫。 \n SSH通訊協定( Secure Shell ) \n 優點: \n 1.SSH相對容易設置，且它的守護程序很常見。 \n 2.透過SSH存取是安全的，所有數據傳輸都經過加密和身份驗證。 \n 3.像HTTP/S、Git與Local protocols一樣，使數據在傳輸之前盡可能緊湊。 \n 缺點: \n 1.無法通過它對存儲庫進行匿名存取。 \n 2.如果想允許匿名存取項目並且還想使用SSH，則必須設置SSH以便推送，但其他內容可供其他人獲取。 \n Git協定 \n 優點: \n 1.為最快的網絡傳輸協議。 \n 2.若為公共項目提供大量流量或為不需要用戶身份驗證進行讀取的大型項，則可能需要設置Git守護程序。 \n 3.Git存儲庫可供所有人克隆。 \n 缺點: \n 1.缺乏身份驗證。 \n 2.通常為唯一存取權限(即推送、寫入等)，若開啟推送存取權限，則網路上能到找到項目的URL並任何人可推送到項目裡。 \n HTTP \n 可分為兩種，分別為新制(智能)與舊制。 \n 新制(智能): \n 與SSH或Git協定的運行方式非常相似，它可以設置為像git://協議一樣匿名服務，也可以通過SSH協議等身份驗證和加密來推送。 \n 舊制: \n 直接將Git存儲庫提供為來自Web服務器的普通文件，優點在於設置它的簡單性。此外，任何可以訪問放置存儲庫的Web服務器的人都可以存取您的存儲庫。 \n 以下優缺點於新制(智能)HTTP \n 優點: \n 1.能夠使用用戶名和密碼進行身份驗證。 \n 2.通過HTTPS以只讀方式提供存儲庫。 \n 缺點: \n 與某些服務器上的SSH相比，在HTTP/S上使用Git可能會有點棘手。 \n \n \n \n \n 在伺服器上佈署Git \n 要clone存儲庫以創建新的存儲庫，請使用該--bare選項運行clone命令。將存儲庫目錄結束.git。如下: \n $ git clone --bare my_project my_project.git \n 現在應該在目錄中擁有Git目錄數據的副本my_project.git。 \n 下面指令相當於類似的東西，但配置文件中存在一些細微差別。 \n $ cp -Rf my_project/.git my_project.git \n 將存儲庫複製到以下來設置新存儲庫： \n 假設/srv/git存在於該服務器上，並且已經設置了一個名為git.example.com的SSH服務器，而希望將所有Git存儲庫存儲在該/srv/git目錄下。 \n $ scp -r my_project.git user@git.example.com:/srv/git \n 之後，對於有這目錄及SSH的權限的用戶就可以來clone，也有推送訪問權限。 \n $ git clone user@git.example.com:/srv/git/my_project.git \n 如果git init使用該--shared選項運行命令，Git將自動將組寫入權限正確添加到存儲庫。 \n $ ssh user@git.example.com $ cd /srv/git/my_project.git $ git init --bare --shared \n \n 產生個人的SSH公鑰 \n 在該目錄並列出內容來輕鬆檢查是否已有密鑰。 輸入指令後有出現文件為id_dsa(id_rsa)為自己私人的密鑰，而文件後方多了.pub則為公鑰。如下: ~/.ssh為目錄 \n $ cd ~/.ssh \n $ ls \n authorized_keys2 \n id_dsa \n known_hosts \n config \n id_dsa.pub \n 如沒有密鑰時，可輸入下列指令來創建。 \n $ ssh-keygen \n 之後，會需要確保密鑰（.ssh/id_rsa）的位置，需輸入兩次密碼，不需要則可空白。 \n 如用戶需要複製有公鑰文件的內容，輸入下列指令。 ~/.ssh/id_rsa為公鑰位置 \n $ cat ~/.ssh/id_rsa.pub \n 伺服器的設定 \n 如要設置SSH存取的服務端，則需使用下列方式來進行身分驗證。 \n **git為用戶名、 .ssh為目錄、authorized_keys為驗證** \n $ sudo adduser git \n $ su git \n $ cd \n $ mkdir .ssh && chmod 700 .ssh \n $ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys \n 如需要為該用戶的文件添加一些開發人員的SSH公鑰，並將其保存到臨時文件中。如下: \n **john為開發人員的SSH公鑰** \n $ cat /tmp/id_rsa.john.pub \n 在一個沒有工作目錄的情況下設置一個空儲存庫。 \n $ cd /opt/git \n $ mkdir project.git \n $ cd project.git \n $ git init --bare \n 將文件推送至遠端儲存庫。 \n **myproject為文件** \n Git常駐程式 \n 如不想將大量的項目或人員都添加SSH密鑰時，以守護進程的方式運行下列指令: 此方法雖然設置方便而快速，但因沒有密鑰的身分驗證，所以任何人都可以存取裡面的內容。多用於世界性的公開項目。 \n $ git daemon --reuseaddr --base-path=/opt/git/ /opt/git/ \n --reuseaddr是允許服務器重新啟動而無需等待舊連接超時 \n --base-path是允許人們克隆項目而不指定整個路徑 \n **最後的路徑需告訴Git守護程序在哪裡查找要導出的存儲庫** \n 如果你正在運行防火牆，你還需要在你正在設置它的盒子上的端口9418處打一個洞。 但建議將此守護程序作為具有存儲庫的唯讀權限的用戶運行。 \n 在Ubuntu計算機上，您可以使用Upstart的腳本，並在文件中放入腳本。 \n **文件為/etc/init/local-git-daemon.conf** \n 腳本: \n start on startup \n stop on shutdown \n exec /usr/bin/git daemon \\ \n --user=git --group=git \\ \n --reuseaddr \\ \n --base-path=/opt/git/ \\ \n /opt/git/ \n respawn \n 要在不重新啟動的情況下運行計算機時 \n $ initctl start local-git-daemon \n 允許未經身份驗證的用戶存取指定的儲存庫。 \n $ cd /path/to/project.git \n $ touch git-daemon-export-ok \n', 'tags': '', 'url': '伺服器上的Git.html'}, {'title': '分散式的Git', 'text': '對Git中的項目做出貢獻以及維護自己的項目或整合其他用戶的貢獻 \n 分散式工作流程 \n 分散式工作流程分為三種 \n 集中式工作流程、整合式管理員工作流程、企業型工作流程 \n \n 集中式工作流程 \n 如前者有人推送，後者必須合併前者的版本，不然會無法推送至儲存庫，是因為避免前者的資料被覆蓋。 \n \n 整合式管理員工作流程 \n 項目維護者=A、開發人員=B \n A推送到他們的公共儲存庫。 \n B克隆該存儲庫並進行更改，並推動他們自己的公共副本。 \n B向A發送一封電子郵件，要求A提取更改。 \n A將B的repo添加為遠程，合併原先的資料，推送到主儲存庫。 \n \n 企業型工作流程 \n 老闆=A、副手=B、開發人員=C \n 正常的C會在他們主題的分支上工作，並在重新定義他們在master上的工作。而master分支是獨裁者的分支。 \n B將C的主題分支合併到B的master分支中。 \n A將B的master分支合併到A的master分支中。 \n A將他們推master送到參考存儲庫，以便其他C可以對其進行重新定義。 \n 分散式的 Git - 對專案進行貢獻 \n 對專案進行貢獻 \n 兩人合作圖 \n \n 兩人以上合作圖 \n \n', 'tags': '', 'url': '分散式的Git.html'}, {'title': 'Fork', 'text': '如果你想參與一個你沒有推送權限的專案，你可以「fork」一份。 \n 這代表說 GitHub會複製一份這個專案的副本給你， 並且你對這副本有全部的權限。 \n 這副本會存在於你的帳號下，你可以對它進行推送。如下 \n 紅色為原作者與原專案，綠色為Fork按鍵 \n \n 按下之後，專案會顯示在自己的底下。 \n \n 之後原專案的Fork會顯示如下 \n \n 先將所Fork到的專案clone下來，新建一個版本後，再回推回去。 \n 這時自己所Fork的專案要回推至原專案時，需要給原作者發送請求，方法如下 \n 到原專案的右方案 \n pull request\xa0 \xa0>\xa0 \xa0New pull resquest\xa0 \xa0>\xa0 \xa0compare across forks\xa0 > 在base fork選原專案的master至head fork選自己專案master\xa0 \xa0>\xa0 \xa0最後按下 Click to create a pull request for this comparison ，這樣就建立起一個pull request了。 \n 最後，我們先看一下右上角有個Able to merge的地方，會預先告訴你合併的結果，顯示你的版本跟原版本是否有衝突發生。 \n 如果都沒問題，可以再輸入一些說明文字給原作者，並按下 Send pull request 即可建立完成。 \n 管理 Pull Requests方面，可能是來自某個 fork 裡的分支， 或是同個倉儲裡的某個分支。而接收到時，會以電郵(信箱)通知。 \n 觀看所接受到的pull resquest沒問題後，按下 Merge pull request 即可完成合併工作。 \n', 'tags': '', 'url': 'Fork.html'}, {'title': 'ungit 手冊', 'text': '', 'tags': '', 'url': 'ungit 手冊.html'}, {'title': 'part1', 'text': '開啟 \n 1.首先打開隨身碟命令提示字元，進入tmp下的組別資料夾，打 kungit \n \n 2.下圖為 ungit 開啟後的版面 \n \n Fetch from origin \n 取得遠端資訊(Fetch from origin)：可以從近端查看想關注之遠端的資訊 \n ◎ origin : 為原本遠端的 github 網址 \n \n ◎取得想關注的遠端資料(add new remote) \n \n (1)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (2)送出後，再點選想要查看的網址名稱 \n \n (3)以下為點開後的圖面 \n \n 子模組Submodules \n 子模組 ( submodules)  : 在資料夾內抓取另一個遠端資料夾內容並新增修改 \n \n ◎新增子模組 (add submodules) \n \n (1)取得想新增的子模組 \n \n (2)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (3)點選上傳子模組(update submodules) \n \n (4)點選想要新增的子模組 \n \n (5)以下為新增的子模組資料 \n \n (6)資料夾內也會顯示新增的資料夾 \n \n 分支Branch \n \xa01.切換分支：點選想要切換的分支即可 \n \xa02.刪除 分支：點選 x 即可刪除 \n ↓1.及2.皆是以下圖來進行操作 \n \n \xa03.add Branch (新增分支)\xa0 \n (1) 點下圖中的圖形即可新增分支或標籤 \n \n (2) 打上名稱(此處以新增 branch 為範例) \n \n (3) 會顯示 aaa 分支 \n \n 4. checkout branch (切換分支) \n 依序下圖進行操作就可以切換分支 \n ↓按下aaa，再點選check out \n \n ↓完成後，即可切換分支 \n \n 5.delete branch\xa0 (刪除分支) \n \n (1)刪除此 aaa 分支或標籤，讓其進行還原 \n \n (2)下圖為還原後顯示的畫面 \n \n 忽略內容 \n 忽略內容 \xa0 .gitignore \n \n → 點擊後顯示的內容 \n \n 以下示範 :\xa0 \n (1)*.a\xa0 →\xa0 將字尾為 .a 的文件都忽略 \n a. 選擇忽略以.txt為結尾的文件 (附檔名可自行選擇) \n \n b. 將 .gitignore 用 scite 開啟 \n \n c. 在 .gitignore 內新增下圖文字 \n \n d. 修改後 .gitignore 會顯示其內容 \n \n e.\xa0.txt的文件已被忽略(如下圖) \n \n (2) !*lib.a\xa0 → 將字尾為 .a 的文件都忽略但 lib.a\xa0 除外 \n a. 以下要示範忽略 .txt 的文件但 456.txt保留 \n  \xa0(附檔名可自行選擇；不忽略檔案也可自行選擇) \n ↓下圖為2個檔案都存在 \n \n b. 在 .gitignore 內新增下圖文字 \n \n c. 檔案以忽略除了456.txt的文件 \n \n', 'tags': '', 'url': 'part1.html'}, {'title': 'part2', 'text': '提交Commit \n 1. Create an empty commit (新增提交) \n 依序下圖步驟操作即可新增提交 \n \n \n \n \n ↓完成後會顯示，如下圖 \n \n 2. Amend previous commit (修改上一個提交) \n \n \n \n ↓完成會顯示，如下圖 \n \n 3.uncommit (不提交) \n \n 下為按下 uncommit 後的圖面 \n \n 從這開始就有不同的步驟去刪除多餘的提交 \n (1) 用 Move 使其刪除 \n →將藍色origin/master拖曳至move \n \n a. \n \n b. \n \n c. \n \n d.\xa0 \n \n (2) 利用 push 推回 \n \n → 按下 push 後也會產生出 a. b. c. d. 圖 \n Tag \n add Tag (新增標籤)\xa0 \n 標籤是對某個 commit 的指標，類似於分支，標籤可分兩種： \n ◎輕量標籤 (lightweight tag)：是指對某個 commit 的指標，沒有包含其他附註資訊，用來個人使用或暫時標註。 \n ◎有附註標籤(annotated tag)：類似於輕量標籤，只是能多附註關於此張標籤的說明及資訊，用於軟體版號等。 \n 新增及刪除標籤步驟跟 branch 相同，在此會用圖說明標籤與分支的不同 \n (1) 在\xa0commit\xa0"test tag-1" 上新增\xa0 "說明標籤與分支的不同" 的標籤 \n \n (2) 新增後 \n \n (3) 提交一個 "test tag-2" 的 commit ，分支 aaa 移至新的提交位置上，而標籤 " 說明標籤與分支的不同 " 停留於原處。 \n \n Megre (合併) \n \n \n \n Move (移動) \n 可用來移動分支，範例如下 \n (1) 點分支 master\xa0 \n \n (2) 按下 Move\xa0 \n \n (3) 詢問是否移動此分支(這個行動有在歷史上出現過) \n \n (4) 下為移動後的圖面 \n \n Cherry pick \n Cherry pick (撿取某分支的 commit 來合併，但不是全部的 commit ) \n (1) 下圖中游標所在位置是想要合併的 commit ，點它 \n \n (2)按下 Cherry pick\xa0 \n \n (3) master所在位置為撿取的 commit\xa0 \n \n \n Revert (還原) \n 再做一個 新 commit ，來取消不要的 commit，原本的 commit 還是會存留在歷史紀錄中。 \n 適合在多人共同協作的專案中，使用 Revert 對於其他協同者來說不算是 修改歷史 ，而是增加一個新的 commit 。 \n (1) 在資料夾中新增 2.txt \n \n (2) 進行 commit and push\xa0 \n \n (3) 點選要進行 revert 的 commit \n \n (4) 點 revert\xa0 \n \n (5) 會顯示出 Rvert "test revert"，此項新 commit\xa0 \n \n (6) 資料夾中的 2.txt 會消失，讓整個資料夾還原 \n \n Reset (重新) \n 直接刪除不要的 commit (會讓歷史中的紀錄改變)，常用在未推交的 commit ，適用於個人的專案。 \n (1) 進行 commit\xa0 \n \n (2) 點游標所在處 \n \n (3) 按 Reset \n \n \n \n Rebase (重新定義參考基準) \n 重新定義某分支的參考基準。每一個 commit 都能增加分支，而分支的基準就是產生出此分支的 commit ，rebase 是能把產生出該分支的 commit 改到另一個 commit ，但是使用 rebase 會影響到 commit 原有的先後關係，所以操作時要多加注意。在此使用範例去解說： \n (1) 利用 scite 建立一個 test rebase.htm ，內容如下圖並另存至資料夾。 \n \n (2) 在分支 master 上進行提交 \n \n (3) 修改先前的 test rebase.htm ，內容如下圖，在分支 master 進行第二次提交。 \n \n (4) 在 test rebase-1的 commit 中增加一個 test 分支。 \n \n (5)\xa0切換至分支 test，在 test rebase-1 的 commit 其所有內容會回至先前的這個 commit 所擁有的內容。 \n \xa0 \n (6) 修改 scite 中的內容，並在分支 test 中提交。 \n \n (7) 在分支 test 執行 rebase \n \n (8) 會讓分支 master 的內容與分支 test 接再一起。 \n \n (9) 最後在資料夾的 test rebase.htm 內容會變成下圖中所展示。 \n \n \xa0 Squash (提交的合併) \n 讓此 commit 與前一個 commit 合併，(但保留原有的 commit )。 \n (1) 建立 test squash 進行提交 \n \n (2) 再進行第二次提交，提交名稱 test squash-1。 \n \n (3) 執行 squash \n \n \n \n', 'tags': '', 'url': 'part2.html'}, {'title': '期中報告', 'text': '', 'tags': '', 'url': '期中報告.html'}, {'title': '40623105', 'text': '\n', 'tags': '', 'url': '40623105.html'}, {'title': '40623118', 'text': '\n', 'tags': '', 'url': '40623118.html'}, {'title': '40623128', 'text': '\n', 'tags': '', 'url': '40623128.html'}, {'title': '40623141', 'text': '\n', 'tags': '', 'url': '40623141.html'}, {'title': '40623156', 'text': '\n', 'tags': '', 'url': '40623156.html'}, {'title': '40623127', 'text': '\n', 'tags': '', 'url': '40623127.html'}, {'title': '40623112', 'text': '\n', 'tags': '', 'url': '40623112.html'}, {'title': '40623135', 'text': '\n', 'tags': '', 'url': '40623135.html'}, {'title': '40623109', 'text': '\n \n', 'tags': '', 'url': '40623109.html'}, {'title': '40623125', 'text': '', 'tags': '', 'url': '40623125.html'}]};