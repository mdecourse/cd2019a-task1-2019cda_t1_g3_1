var tipuesearch = {"pages": [{'title': '組員', 'text': '40623105 \n 40623109 \n 40623112 \n 40623118 \n 40623125 \n 40623127 \n 40623128 \n 40623135 \n 40623135 \n <<<<<<< HEAD \n 40623141 \n 40623156 \n', 'tags': '', 'url': '組員.html'}, {'title': '執行規劃-1', 'text': '======= \n 40623141 \n 40623156 \n', 'tags': '', 'url': '執行規劃-1.html'}, {'title': '執行規劃-2', 'text': '>>>>>>> 6eb88f12790e91e1cfad6d9c53c00d4fe3faab35 \n 此規劃並非硬性規定製作時間，可自行提早完成。 \n 送球機構設計與模擬 \n 第十三週前 製作運球機構 \n 第十五週前完成配合足球台 \n 手足球模擬 \n 第十三週前 完成簡化與設定 \n 第十五週前完成配合送球機構 \n 零組件尺寸分析&參數設計與繪圖 \n 第十一週前 設計足球台 \n 第十三週前 設計功能ex伸縮 \n 第十五週前完成整體 \n 系統功能 \n 第 十三 週 前 完成系統功能 程式 \n 第十五週前修復程式問題 \n 製作pdf和投影片 \n 第十六週與第十七週 \n 自行製作所負責的部分 \n 盡量於第十六 週 前完成 \n 第十七週完成最後校閱 \n \n', 'tags': '', 'url': '執行規劃-2.html'}, {'title': '手足球系統模擬', 'text': '', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': '設計與繪圖', 'text': '', 'tags': '', 'url': '設計與繪圖.html'}, {'title': '零組件尺寸分析', 'text': '手足球系統的零組件尺寸分析 (可行性分析) \n 1.球桌: \n A.球桌內部角落的部分，之前模擬的時候，會有卡球的問題，看了網路上的影片，打到角落時也會有要用手撿球的問題，所以將角落做了一點翹高大概2mm。 \n B.手柄距離也在做微調，太近的話，手沒有辦法握住求柄，即使能夠握住，靠得太近也會影響使用者的感受，反之，太寬使用者也不好操作，尺寸設計在雙手在腰間的寬度還要小比較合適。 \n C.球門及場地的大小，參考網路上標準場地的尺寸來做設計。球桌高度大概是在腰間的，但是每個人的身高不同，我們評估下來腰間上下150mm，使用者的感受都是可以接受的。 \n ↓下圖為設計球桌時所繪製的草圖 \n \n 2.桿子: \n 本來想說用1000mm移動距離會剛好，但是加上手柄之後，視覺上有一點太窄了，所以把長度加了200mm，讓桿子的2編對稱個增長100mm。 \n ↓下圖為設計球桌時所繪製的草圖 \n \n 3.球員: \n 本來設定70會有一點卡到地板，轉動時也會有球員互相卡到的問題，所以又把尺寸稍微修小一點，改善這樣的狀況。 \n ↓下圖為設計球桌時所繪製的草圖 \n \n 4.手柄: \n 握柄太短會讓使用者握不滿手柄，造成不好使用的情況，起初設定100，但後來考量到有些人手掌會比較大的問題，所以多加了25mm。 \n ↓下圖為設計球桌時所繪製的草圖 \n \n 5.組裝時，尺寸限制: \n 5個足球員的時候，因為當初沒有把篩子的大小考慮進去，所以把人偶之間的距離設成200，後來發現這樣距離會太大人偶移動的距離變得很少，後來改成107。 \n ↓以下為初步尺寸限制的草圖 \n \n ↓以下為最終尺寸限制的草圖 \n \n 40623105 \n \n 40623109 \n \n 40623118 \n \n \n 6.送球軌道: \n 由於尺寸過小的關係，再加上需要配合送球機構以及軌道的關係修改了相當多次，為配合到機構之間的距離將尺寸從120改成135 \n \n 7.送球機構: \n 在撥桿的部分原本是呈現長方形的，因考慮到了沒有角度在撥球時可能會造成球的動向無法預期，所以在兩邊斜面的部分增加了10度的傾角。 \n \n 搭配撥桿的造型後，在外殼的設計上各增加了厚度5mm，而在與撥桿相差2mm的誤差是因為組員反映出在v-rep模擬時兩機件會互相干涉，所以更動了原先的尺寸。 \n \n 在進球口高度的設計上，為了方便負責軌道組員的製作，所以將孔的位置標於圓的底部，而球口的高度也有經過設計，與撥桿的部分切齊在進球時不會造成干涉。 \n \n \xa0  \n 8.球門: \n 球門的外型依照球桌的大小與軌道的進球口進行尺寸配合，內部為了讓球可以順利的進入軌道進行了多次的斜度變動，在進球口處也利用圓角讓球可以更順暢的流通，外型用Draft分上下殼修改外型的斜度。 \n \n', 'tags': '', 'url': '零組件尺寸分析.html'}, {'title': '參數設計與繪圖', 'text': '', 'tags': '', 'url': '參數設計與繪圖.html'}, {'title': 'w11進度', 'text': '本周進行人員的工作分配，王柏翔與鍾旻諺分配到參數設計與繪圖的工作，我們先上網搜尋手足球桌的國際規格之後，參考國際比賽桌的尺寸之後再做了一些些微的調整，為了之後設計和配合可以方便一點。 \n \n \n', 'tags': '', 'url': 'w11進度.html'}, {'title': 'W12進度', 'text': '本周繪製完(球桌)(球員)，和一些((手把)和串聯球員的(桿件)，以及另外一個分工小組的分球機構還在等我們的尺寸確定，他們的送球軌道尺寸才能配合到我們的球桌上，配合之後我們兩邊再去做一些尺寸的微調，讓分球機構能完美的和球桌合體。 \xa0 \xa0 \n \n 球桌、手把、零件 \n', 'tags': '', 'url': 'W12進度.html'}, {'title': 'W13進度', 'text': '本周我們進行零組件、送球機構、足球桌的組裝，組裝之後我們發現各組件在配合上有些許的誤差，在設定球員和手把連桿時我們為了設定它的移動範圍花了許多的時間，因為不知道為什麼同樣的參數卻不能套用在同位置的球桿上，所以我們只好每根都自己慢慢的去試，才不會讓它過度移動(例如整根拔出來)，不過在其他組員分工的幫忙下順利的組裝完成了。 \n', 'tags': '', 'url': 'W13進度.html'}, {'title': 'W14進度', 'text': '我們把所有機構做組裝，發現球員與球員間會互相碰撞所以去做了尺寸上的更改，把球員長度改到以下尺寸並把球桌的洞上下間距做更改。 \n \n', 'tags': '', 'url': 'W14進度.html'}, {'title': 'W15進度', 'text': '我們前兩個禮拜已經把所有機構做好限制，這禮拜做最後檢查然後就把圖交由操作V-rep組員去做簡化與模擬。 \n (以下的圖是要放在reveal裡的) \n \n', 'tags': '', 'url': 'W15進度.html'}, {'title': '細部設計與 BOM', 'text': '發球機構:\xa0 \n 1.發球機構本體: \n 工程圖連結網址請點這 \n \n 2.撥桿: \n 工程圖連結網址請點這 \n \n 3.球門外型: \n 工程圖連結請點這 \n \n 4.足球員 \n 連結 \n \n 5.桿子 \n 連結 \n \n 6.塞子 \n 連結 \n \n 7.球桌 \n 工程圖連結 \n \n 8.手把 \n 工程圖連結 \n \n 9.送球軌道 \n 工程圖連結 \n \n 爆炸圖 \n 連結 \n \n', 'tags': '', 'url': '細部設計與 BOM.html'}, {'title': 'V-rep 動態模擬', 'text': '\xa0人物簡化 \n 首先在 onshape 將想要使用的零件圖或組合圖按照圖 1.1 及圖 1.2 匯出成 .stl 檔，再從 v-rep 中開啟 .stl 檔(使用[ File --> Import --> Mash... ])，會出現如圖 1.3 的對話框，依據個人所需去做點選，在按 OK 即可在視窗中導入模型。可以從圖 1.4 中看出，導入的模型是未分離的模型(如若是零件圖則不須此步驟)，所以我們使用[ Edit --> Grouping/Merging --> Divide selected shapes ]來將模型中的物件全都爆開，如圖 1.5。 \n 圖1.1：onshape匯出 \n \n 圖1.2： onshape匯出對話框 \n \n 圖1.3： 匯入 .STL 檔後的對話框 \n \n 圖1.4： 分離模型步驟點選 \n \n 圖1.5： 模型爆開後 \n \n 接下來說明人物簡化步驟，先來進行人物頭部的簡化，先選擇人物將其複製(使用[ Edit --> Copy selected Objects ])到一個新建的場景(使用[ File --> New scene ])，再將人物貼上(使用[ Edit --> Paste buffer ])。再點選 頁面選擇器工具欄按鈕 \xa0，如圖1.6，使得在簡化的過程中更容易點選，接著選取人物再點選\xa0 形狀編輯模式工具欄按鈕 \xa0來進行簡化，如圖1.7，在此我框選人物的頭部如圖1.8，再點選簡化的對話框 Operations on selected triangles 中的 Extract cuboid 如圖1.9，之後會出現 Primitive cuboid 的對話框並按下 OK 即會產生一個立方體如圖1.10，頭部的簡化就完成了，再將簡化對話框關閉，此時會出現 Shape edit mode 對話框詢問是否應用這些變化嗎？(點擊否會保 留提取的對象)，所以在這選擇 No 將新加入的物件保留。 \n 圖1.6： 頁面選擇器工具欄按鈕 \n \n 圖1.7： 形狀編輯模式工具欄按鈕 \n \n 圖1.8： 框選人物頭部 \n \n 圖1.9： 簡化的對話框 - 人物 \n \n 圖1.10： 頭部簡化完成後 \n \n 再來要說明人物身體的簡化，其簡化步驟和人物頭部簡化很相似，所以直接跳至身體簡化所需框選的部位如圖1.11，之後再點選簡化的對話框 Operations on selected triangles 中的 Extract cuboid 如圖1.9，身體簡化完的圖片如圖1.12。 \n 圖1.11： 框選人物頭部以下的部位 \n \n 圖1.12： 頭部簡化完成後 \n \n 人物的簡化就到這，接著要將兩個新增的物件合併成一個全新的物件，先將兩個物件選取(使用[ Edit --> Grouping/Merging --> Group selected shapes ])，如圖1.13，新物件的名稱為 people_dyn ，之後在剪下貼回第一個場景，如圖1.14。 \n 圖1.13： 合併物件 \n \n 圖1.14： 新物件people_dyn新加並貼回原位 \n \n 其餘人物的簡化可以使用複製將剛剛簡化後的新物件複製在貼上，如圖1.15，之後點選新貼上的物件使用 Ctrl 在選取其他尚未簡化的一個人物，如圖1.16，點擊操作 物件傳送工具欄按鈕 \xa0如圖1.17，會出現工具欄按鈕對話框，如圖1.18，點選 Postion 中的 Apply to selection 使新貼上的物件能和為簡化的人物箱貼合，如圖1.19，這樣就無需再簡化無限多次。 \n ! 圖1.15： 合併物件 \n \n 圖1.16： 使用ctrl在點擊工具欄按鈕 \n \n 圖1.17： 物件傳送工具欄按鈕 \n \n 圖1.18： 工具欄按鈕對話框 \n \n 圖1.19： 貼完後 \n \n 軸、篩子簡化 \n 在來先進行軸的簡化，複製軸到新的場景，選取軸並點選形狀編輯模式工具欄按鈕，如圖1.7，將軸全部框選，如圖2.1，再點選簡化的對話框 Operations on selected triangles 中的 Extract cylinder 如圖2.2，之後會出現 Primitive cylinder 的對話框並按下 OK 即會產生一個圓柱如圖2.3，將新圓柱物件命名為 Cylinder_dyn，並剪下貼回第一場景上即可。 \n 圖2.1： 框選軸需簡化的部分 \n \n 圖2.2： 簡化對話框 - 軸 \n \n 圖2.3： 軸簡化後產生的新圓柱 \n \n 接下來要進行篩子的簡化，複製篩子至新的場景，之後的簡化也和軸非常相似，選取篩子並點選形狀編輯模式工具欄按鈕，將篩子全部框選進行簡化，如圖2.4，再點選簡化的對話框 Operations on selected triangles 中的 Extract cylinder ，之後會出現 Primitive cylinder 的對話框並按下 OK 即會產生一個圓柱如圖2.5，將新圓柱物件命名為 s1_dyn，並剪下貼回第一場景上即可。 \n 圖2.4：框選篩子需簡化部分 \n \n 圖2.5：篩子簡化後產生的新物件 \n \n 其餘的篩子及軸的簡化，可以參考人物簡化的最後一段。 \n 足球桌簡化 \n 足球桌簡化 --- \n 影片簡易版 \n Toggle shape edit mode(左六)僅對於"一個"物體作簡化形成多個三角形 \n 先開啟另一個New scene，將球桌複製過來做簡化。 \n 球桌長板子有兩種方式，按Toggle shape edit mode後， \n 1.為選取所想要的平面(可不須全選)，選取四角後按Extract cuboid後(系統會將所選所有三角形自動計算出最大尺寸)。 \n 選取三角形後按Extract cuboid \n \n OK \n \n 關閉Shape Edition後按 NO \n \n Scene objects properties(左二)>Shape>View/modify geometry>Keep proportions取消勾選，在Bounding box size長厚度後，在Object/item shift(上七)座移動，與球桌對齊。 \n View/modify geometry \n \n 取消勾選並調整板厚 \n \n X方向調整 \n \n 調整位置 \n \n \n 2.為選取所想要的平面(可不須全選)，選取四角後"再選取平面上方三角形(厚度)"Extract cuboid後(系統會將所選所有三角形自動計算出最大尺寸)，就完成了。 \n 多選取板厚的三角形 \n \n 選取完後一樣按Extract cuboid>OK>關閉Shape Edition>NO \n 兩種方式厚度比較 \n \n 其他地方的板子操作也是如此，之後會發現板子相互干涉，但對模擬或是簡化不會有影響。 \n 簡化後的板子相互干涉 \n \n ** \n Extract shape 為類似像皮膚一樣的一層 \n Extract cuboid 為長平板 \n Extract cylinder 為長圓柱 \n Extract sphere 為長球 \n \n 模擬步驟 \n 將所有物件都簡化好後，開始進入模擬的步驟，為了在 場景層次結構 中的物件更好找到，將所有的物件都命名能更快的找的所需要使用的物件。首先先加入平移軸 Prismatic joints \xa0(使用[Add-->Joint-->Prismatic])及旋轉軸 Revolute joints \xa0(使用[Add-->Joint-->Revolute])，並分別命名為 Prismatic_joint_1 及 Revolute_joint_1 ，之後將所有我需要用的物件都拉到 Table_dyn 下，如圖4.1及圖4.2。 \n 圖4.1：將所需物件拉入 Table_dyn 下-1 \n \n 圖4.2：將所需物件拉入 Table_dyn 下-2 \n \n 選取 Prismatic_joint_1 (平移軸)及 cylinder_L1_dyn (軸)並點選物件傳送工具欄按鈕如圖x . x，會出現 Object/Item Translation/Position的對話框，切換至 Postion 按下按鈕 Apply to selection ，平移軸及軸會相貼合，如圖4.3，再點選 物件旋轉工具欄按鈕 圖4.4，會出現 Object/Item Rotation/Orientation的對話框，切換至 Orientation 按下按鈕Apply to selection ，平移軸及軸方向會相同，如圖4.5，之後的旋轉軸也是一樣的方法，圖4.6可以看出平移軸、旋轉軸及軸位置及方向都相同。 \n 圖4.3：平移軸和軸相貼合 \n \n 圖4.4：物件旋轉工具欄按鈕][8-1] \n \n 圖4.5：平移軸和軸方向相同 \n \n 圖4.6：平移軸、旋轉軸及軸位置及方向皆一致 \n \n 再將拉入 Table_dyn下的物件依照圖4.7 去排序，在選取物件 h_L1、 people_L1_1 、 s_L1_1 及 s_L1_2 (使用[Edit-->Grouping/Merging-->Group selected shapes])將物件合併，命名為 h_L1 ，另一部分的 people_L1_1_dyn 、 s_L1_1_dyn 及 s_L1_2_dyn 也一樣使用相同方法進行合併，命名為 s_L1_2_dyn ，完成後如圖4.8。 \n 圖：4.7樹狀圖排列 \n \n 圖4.8：合併並排列好 \n \n 之後點擊兩次 Table_dyn 前的圖案，會產生 Scene Object Properties 點選 common ，將 Visibility 下的 Camera visibility layers 中的勾勾關掉，如圖4.9，將 s_L1_2_dyn 及 cylinder_L1_dyn 也使用相同方式關閉圖層。    圖4.9：Scene Object Properties 對話框 \n \n 點擊兩次 Table_dyn 前的圖案，並點及對話框中的 Show dynamic properties dialog，會出現另一個 Rigid Body Dynamic Properties 對話框，將 Body is respondable 打勾，再將 Local respondable mask 從第3個勾開始不打勾到第8個，如圖4.10；再來點擊兩次 cylinder_L1_dyn 前的圖案，依照圖4.11去進行勾選，其中打開 Body is dynamic 能使物體產生動態；再點擊兩次 s_L1_2_dyn 前的圖案，依照圖4.12 去進行勾選。 \n 圖4.10：對話框勾選 - Table_dyn \n \n 圖4.11：對話框勾選 - cylinder_L1_dyn \n \n 圖4.12：對話框勾選 - s_L1_2_dyn \n \n 接下來要讓軸能轉動，所以點擊兩次 Prismatic_joint_1 前的圖案，在按下 Show dynamic properties dialog ，會產生 Joint Dynamic Properties 將 Motor properties 下的 Motor enabled 打勾，在 Target velocity 打入0.001，如圖4.13 所展示；再來點擊兩次 Revolute_joint_1 前的圖案，在按下 Show dynamic properties dialog ，會產生 Joint Dynamic Properties 將 Motor properties 下的 Motor enabled 打勾，在 Target velocity 打入1，如圖4.14，最後看圖4.15 可以看到模擬。 \n 圖4.13：對話框勾選 - Prismatic_joint_1 \n \n 圖4.14：對話框勾選 - Revolute_joint_1 \n \n 圖4.15：模擬圖 \n \n', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': 'V-rep簡化與模擬測試', 'text': 'V-rep簡化與模擬 \n 簡化與模擬測試 \n 40623105 \n 0506 \n \n 0513 \n \n 0520 \n \n 0527 \n \n 40623109 \n 0506\xa0 \xa0 \n \n 0513 \n \n 0520 \n \n 0525 \n \n \n \n 0527 \n \n 40623118 \n 0506\xa0 \xa0\xa0 影片1\xa0  \xa0  影片2 \n 0512\xa0 \xa0  影片1  \xa0 \xa0 影片2   \n 0513\xa0 \xa0\xa0 影片1 \n 0519\xa0 \xa0  影片1  \xa0  影片2 \n 0520 \n \n \n 0522 \n \n 0523 \n \n 0528 \n \n 0529 \n \n 0530 \n \n 40623127 \n 0527-1 \n \n 0527-2 \n \n .40623156 \n \n', 'tags': '', 'url': 'V-rep簡化與模擬測試.html'}, {'title': '簡化與模擬測試問題與討論', 'text': '0519 \n Vrep Divide selection shapes error 模擬分解錯誤疑慮 \n 如影片所示，在Onshape繪製零件與組裝時，零件都是分別繪製與組裝。 \n 但到了Vrep進行Divide selection shapes 卻是一體的，無法再次分解，如下圖所示。 \n 疑慮 : \n 紅色方框應對應到足球桌本體，而下方三個水藍色方框應再分別再對應出另外三個物體。 \n \n 0520 \n 解決方法為更改發球機構的尺寸 \n 發球機構 \n \n 更改前 \n \n 更改後 \n \n 與同學討論後，如圖發球機構的淺藍色尺寸不應該深藍色尺寸一致，不然模擬V-rep時恐會使這兩部分零件形成一體。 \n 而桌子下方三個零件不須模擬期動或轉動，所以配合尺寸無更改。 \n 0520 \n 期中後到今天摳可以使用40623128(組長)所fork的Github，但今天卻發現無法編輯任何東西，也沒顯示任何內文，如下圖。 \n \n 0523 \n 與組長討論過後，懷疑是否是因為之前自行製作可攜系統而下載的python3.7.2在背景執行所導致的。 \n 刪除過後已可以看到內文與可以編輯，但無法完全確定是否完全是因為python的問題。 \n', 'tags': '', 'url': '簡化與模擬測試問題與討論.html'}, {'title': '送球機構設計與模擬', 'text': '負責組員 : \n 40623127 張育偉 \n 40623135 洪明棋 \n 40623156 林聖翰 \n', 'tags': '', 'url': '送球機構設計與模擬.html'}, {'title': '送球機構模擬', 'text': '40623127 \n 簡易軌道測試，目的在於測試軌道尺寸是否有問題，及是否能順利進入送球機構內 \n \n .40623156 \n 製作發球機構模擬，確定發球機構能順利進行發球的動作。 \n \n 40623135 \n 測試球進球門後能不能夠順利從進球口進入軌道裡。 \n \n', 'tags': '', 'url': '送球機構模擬.html'}, {'title': '送球機構每周進度', 'text': 'W11進度 \n 本周進行人員分配工作，由 張育偉、洪明棋、林聖翰等三人所負責，在初步的討論下已有了各自的課題，由明棋負責送球軌道和球門下集球通道的設計及繪製，聖翰負責將球翻轉送上球檯的翻轉平台，而育偉則是Onshape的組裝以及V-rep的模擬，暫定將於三周內完成並將由其他成員完成程式的部分。 \n \n W12進度 \n 本周的進度是把送球機構的雛型加強，明棋將球門的斜度與寬度還有出球口重新做調整，聖翰將翻轉平台配合軌道重新調整了尺寸以及修正槽內的平台角度，育偉配合兩道球門的出球口與兩個反轉平台進球口架設兩條軌道。 \n \n \n W13進度 \n 本周進行由三人所繪製之零組件以及足球桌的組裝，組立上可以發現各組件上存在著許多配合上的誤差，從這裡可以看出組員之間的溝通並沒有妥善的說明清楚，這亦是協同設計上不可忽視的一點，其中軌道的部分修改最為多次，主要是因為與其連接的零組件定位方面須考慮非常多。 \n \n W14進度 \n 送球機構與球桌搭配下修改機構的設計與組配全部完成，手邊任務告一段落的組員也試著將自己所做的部分轉成STL檔放入V-rep進行初步的製作。 \n W15進度 \n 本周將在Onshape所繪製之運球機構組匯入至V-rep，由於程式尚未完成的關係，只進行簡化以及測試軌道是否可以順利將球運送到指定地點。 \n W16進度 \n 將送球機構整個過程的零件進行修改，讓球可以順利的循環至指定地點，程式部分尚未完成所以無法達到預期經由sensor偵測後把球送給指定方。將所有零件資料與零件bom圖從onshape整理出來。 \n \n', 'tags': '', 'url': '送球機構每周進度.html'}, {'title': '送球機構問題與討論', 'text': "w11討論 \n 首先的問題是如何將球送上場地，一開始是以場地上方、下方以及兩側的位子出發去找出那個位置所對應的其合適的方法，場地上方是一開始就不去考慮的，在上方的話軌道會影響遊玩者的視線，而顯得有些礙眼；場地側面則是把手將其裝設的空間給佔據，受空間受限而改用其他位置來考慮，因此重點部分決定由下方來著手，下方有的問題該屬如何將場地諞面填平，想的方法千奇百怪甚至有點天馬行空，最終定案為由場地下方送球，在中心處挖洞設置一個翻轉的撥球平台。 \n w12討論 \n 本周的問題'將所有設計出來的機構調整尺寸到最佳化，球門方面調整了斜面以及送球口的尺寸，以便後續球在模擬時不會卡住，軌道將雛型設計出來並搭配球門與撥球平台。為了方便製造，原本兩個球門進球後會從撥球平台不同側經由軌道送入裡面，經過討論我們重新設計讓球都經由同一側進入撥球平台的槽中。 \n w13討論 \n 本周發現繪製軌道會過於複雜而在軌道的設計上因斜面的空間有限，以至於無法將軌道設計成雙向進入，所以進一步的調整回原本的雙向送球，也將送球平台再改回雙孔的設計。 \n 問題 \n 到13週送球機構已全部完成，但是在簡化時發現了問題，由於尺寸太過於剛好，導致匯出成STL檔到V-rep時會變成無法分解的一個零件，最後是由將之間配合的公差給予來解決這個問題。 \n w15討論 \n 在完成送球機構繪製及組裝後來到了V-rep模擬的部分，由於此處所需作業僅一人足夠，所以在討論下決定由一人完成其他人仍可錄製影片上傳。 \n w16討論 \n 本周將所有的送球機構與其他的手足球桌零件配合完成，並且並搭配球上去進行了V-rep模擬。除了模擬運行過程我們也在進入撥球平台的兩個入口各加一個cone senser，讓撥球平台知道讓球撥往哪一方。 \n 問題 \n 球在運行過程中在球門往送球機構的軌道中會有卡住的情況，所有組員們在模擬時也加以修改了球門內的斜坡。 \n", 'tags': '', 'url': '送球機構問題與討論.html'}, {'title': '系統功能展示', 'text': '', 'tags': '', 'url': '系統功能展示.html'}, {'title': 'Ag3-足球台模擬進度', 'text': 'w11 \n 這週的進度是分配工作，v-rep 模擬的部分是由陳微云40623105，李如芳40623109，楊秉澤40623118來負責，張華倞40623128（組長）則是幫助我們有困難的地方，幫助我們解決問題。總共分成兩個部分，第一部分是簡化，第二部分是處理樹狀圖加模擬。一開始因為還要設計及畫圖，所以這週整組先一起設計球桌大小及各個零件的大小，並上網查資料再一起討論。 \n ●若要查看設計尺寸，請看設計與繪圖→零件與尺寸分析 (1.2.3.4) \n https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E9%9B%B6%E7%B5%84%E4%BB%B6%E5%B0%BA%E5%AF%B8%E5%88%86%E6%9E%90.html \n w12 \n 這週的進度是先用之前的圖檔熟悉簡化的操作，並處理樹狀圖，嘗試模擬。 \n 將樹狀圖處理好成可以轉動的狀態，但只能轉動不能左右移動，還再進行修改。 \n 將軸裝在手柄上，嘗試看看能不能用手柄驅動桿子，進而驅動球員。 \n 將人偶簡化，嘗試能不能將桿子和人偶合併再一起簡化。 \n 40623105 \n \n \n 40623109 \n \n 40623118 \n \n \n w13 \n 這週因為繪圖組的還需要時間畫圖，所以仍然用舊的圖檔進行簡化跟模擬。 \n 將球桌簡化，把球門的部分分開來建模，否則形狀會很奇怪，插入桿子的部分，因為洞口的關係，簡化會變得比較複雜，要經過建模變成一體的比較好操作。 \n 處理樹狀圖，插入軸後，要讓手柄，桿子，及人偶一起連動，並能左右移動。但是出現了會一起掉落的問題，仍在處理中。 \n 40623105 \n \n 40623109 \n \n 40623118 \n \n w14 \n 因為繪圖組的出現限制錯誤的問題，所以這週過去支援繪圖組裝的部分。 \n 詢問繪圖組後，發現他們對於組合圖的組裝尚未完成，並不熟悉限制條件與方式，也示範一次如何組裝並錄製影片，由於需反覆的調整與限制方式，所以我們這周與他們討論並一起解決問題。 \n ●若要查看尺寸設計的部分，請看設計與繪圖→零件與尺寸分析(5) \n https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E9%9B%B6%E7%B5%84%E4%BB%B6%E5%B0%BA%E5%AF%B8%E5%88%86%E6%9E%90.html \n 5/22(三) \n 繪圖組圖檔已完成，所以正式對最終圖檔進行簡化。 \n 篩子及桿子簡化成圓柱，球員則是建樺呈方形即可。 \n 40623118 \n \n 5/23(四) \n 球桌簡化的部分，每一塊板子都要分別建模。 \n 球門的部分要分開來建模，如果整塊板子一起用的話，球門會封住。 \n 40623118 \n \n 5/25(六) \n 本來以為簡化完要跟原來的外型一樣才算成功，所以把每一個不同的面，都分開來建模，但是篩子只需要簡化成圓柱狀即可。 \n 40623109 \n \n \n \n \n w15 \n 手把不需特別簡化，將其餘的模型簡化，並貼在本體上，完成。 \n 40623105 \n \n 40623109 \n \n', 'tags': '', 'url': 'Ag3-足球台模擬進度.html'}, {'title': '玩家對打', 'text': '程式利用 python 的 keyboard mudule 來配和按鍵控制 \n 所使用的是 keyboard.is_pressed ，如果按下鍵，則返回 True \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV =360   \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        try:\n            if keyboard.is_pressed(\'c\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'v\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            if keyboard.is_pressed(\'z\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0.2,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'x\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,-0.2,vrep.simx_opmode_oneshot_wait)\n            else:\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0,vrep.simx_opmode_oneshot_wait)\n        except:\n            break \n        try:\n            if keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            if keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.1,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.1,vrep.simx_opmode_oneshot_wait)\n            else:\n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n        except:\n            break \n        MMMB = Bv*2\n        MMMR = Rv*2\n    vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n 程式檔 \n \n', 'tags': '', 'url': '玩家對打.html'}, {'title': '電腦對打', 'text': '\n 由於在舊版的程式裡，會發生球滾到桿子後會造成無法回擊，因此修改完成以下程式 \n 所以再程式裡加上 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n if   position_S[ 0 ] > =   1.185   and   RRev_deg > =   25 :\xa0  #球進入擊球區 and 桿子擊出 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   position_RR[ 1 ]> = 0.5 :\xa0  #桿子偏右邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RMo_handle,  - 0.08 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RRev_handle, B_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   position_RR[ 1 ] <  0.5 :\xa0  #桿子偏左邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RMo_handle,  0.08 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RRev_handle, B_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \n \n \n \n \n \n \n 再擊出球後能往旁邊移動收回桿子，進行下段程式。 \n 如果球進入擊球區桿子在收回的情況下，球與球員進入x軸-0.01~0.01範圍內 \n 則球員會將球擊出 \n 未進入x軸-0.01~0.01範圍內時則桿子保持收回 \n 未進入擊球範圍時桿子保持收回 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n \n \n \n elif   position_S[ 0 ] > =   1.185   and \xa0  RRev_deg < = 0 :\xa0  #球進入擊球區 and 桿子收回 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 if   Rv> =   - 0.01   and   Rv < 0.01 :\xa0  #進入左右擊球範圍 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RRev_handle, R_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(RRev_handle, B_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n elif   position_S[ 0 ] <  1.185 :\xa0  #球未進入擊球區 \n \xa0\xa0\xa0\xa0 speed(RRev_handle,B_KickBallVel) \n \n \n \n \n \n \n \n \n 程式檔 :  舊程式檔   新程式檔 \n 程式碼: \n import vrep\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 45     #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef speed(handle,vel):\n    vrep.simxSetJointTargetVelocity(clientID,handle,vel,vrep.simx_opmode_oneshot_wait)\n\ndef getballposition():\n    #for i in range(steps):\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    \n    errorCode,RRev_pos=vrep.simxGetJointPosition(clientID,RRev_handle,vrep.simx_opmode_streaming)\n    errorCode,BRev_pos=vrep.simxGetJointPosition(clientID,BRev_handle,vrep.simx_opmode_streaming)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[0] - position_RR[0]\n    while (n == 1):\n        \n        errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n        errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n        errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n        Rv =position_S[1]- position_RR[1]\n        RRv =position_S[0] - position_RR[0]\n        Bv =position_S[1]- position_BR[1]\n        BRv =position_S[0] - position_BR[0]\n        \n        errorCode,RRev_pos=vrep.simxGetJointPosition(clientID,RRev_handle,vrep.simx_opmode_streaming)\n        errorCode,BRev_pos=vrep.simxGetJointPosition(clientID,BRev_handle,vrep.simx_opmode_streaming)\n        RRev_deg = (RRev_pos/math.pi)*180\n        BRev_deg = (BRev_pos/math.pi)*180\n        \'\'\'\n        print(position_S[0])\n        sleep(2)\n        \'\'\'\n   \n        if position_S[0] >= 1.185 and RRev_deg >= 25:  #球進入擊球區 and 桿子擊出\n            if position_RR[1]>=0.5:  #桿子偏右邊\n                speed(RMo_handle, -0.08)\n                sleep(0.2)\n                speed(RRev_handle, B_KickBallVel)\n                sleep(0.2)\n                \n            elif position_RR[1] < 0.5:  #桿子偏左邊\n                speed(RMo_handle, 0.08)\n                sleep(0.2)\n                speed(RRev_handle, B_KickBallVel)\n                sleep(0.2)\n                \n        elif position_S[0] >= 1.185 and  RRev_deg <=0:  #球進入擊球區 and 桿子收回\n            \n            if Rv>= -0.01 and Rv <0.01:  #進入左右擊球範圍\n                speed(RRev_handle, R_KickBallVel)\n                \n            else:\n                speed(RRev_handle, B_KickBallVel)\n                \n        elif position_S[0] < 1.185:  #球未進入擊球區\n            speed(RRev_handle,B_KickBallVel)\n\n        if position_S[0] <= 0 and BRev_deg <= -25: #球進入擊球區 and 桿子擊出\n            if position_BR[1]<=0.5: #桿子偏右邊\n                speed(BMo_handle, 0.08)\n                sleep(0.2)\n                speed(BRev_handle, R_KickBallVel)\n                sleep(0.2)\n            elif position_BR[1] > 0.5: #桿子偏左邊\n                speed(BMo_handle, -0.08)\n                sleep(0.2)\n                speed(BRev_handle, R_KickBallVel)\n                sleep(0.2)\n                \n        elif position_S[0] <= 0  and  BRev_deg >=0:\n            \n            if Bv>= -0.01 and Bv <0.01:\n                speed(BRev_handle, B_KickBallVel)\n                \n            else:\n                speed(BRev_handle ,R_KickBallVel)\n        elif position_S[0] > 0:\n            speed(BRev_handle,R_KickBallVel)\n        MMMR = Rv*1.2\n        MMMB = Bv*1.2\n        vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n\n\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '電腦對打.html'}, {'title': '玩家vs電腦', 'text': '由電腦對打和玩家對打程式合併加以修改 \n 完整程式碼 : \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n \n \n \n import   vrep \n import   keyboard \n from   time  import   sleep \n import   sys, math \n # child threaded script:  \n # 內建使用 port 19997 若要加入其他 port, 在\xa0 serve 端程式納入 \n #simExtRemoteApiStart(19999) \n \xa0 \xa0 \n vrep.simxFinish( - 1 ) \n \xa0 \xa0 \n clientID  =   vrep.simxStart( \'127.0.0.1\' ,  19997 ,  True ,  True ,  5000 ,  5 ) \n KickBallV  =   45 \xa0\xa0\xa0\xa0  #手把轉速設定(度/秒) \n Move_Minus  = - 0.1 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  #手把水平移速(m/s) \n Move_Plus  = 0.1 \n n = 1 \n R_KickBallVel  =   (math.pi / 180 ) * KickBallV \n B_KickBallVel  =   - (math.pi / 180 ) * KickBallV \n if   clientID! =   - 1 : \n \xa0\xa0\xa0\xa0 print ( "Connected to remote server" ) \n else : \n \xa0\xa0\xa0\xa0 print ( \'Connection not successful\' ) \n \xa0\xa0\xa0\xa0 sys.exit( \'Could not connect\' ) \n \xa0 \xa0 \n errorCode,Sphere_handle = vrep.simxGetObjectHandle(clientID, \'Sphere\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,BRod_handle = vrep.simxGetObjectHandle(clientID, \'BRod\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,BRev_handle = vrep.simxGetObjectHandle(clientID, \'BRev\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,BMo_handle = vrep.simxGetObjectHandle(clientID, \'BMo\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,RRev_handle = vrep.simxGetObjectHandle(clientID, \'RRev\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,RMo_handle = vrep.simxGetObjectHandle(clientID, \'RMo\' ,vrep.simx_opmode_oneshot_wait) \n errorCode,RRod_handle = vrep.simxGetObjectHandle(clientID, \'RRod\' ,vrep.simx_opmode_oneshot_wait) \n if   errorCode  = =   - 1 : \n \xa0\xa0\xa0\xa0 print ( \'Can not find left or right motor\' ) \n \xa0\xa0\xa0\xa0 sys.exit() \n \xa0\xa0\xa0\xa0 \xa0 \n def   stop(): \n \xa0\xa0\xa0\xa0 errorCode  =   vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0 \xa0 \n def   start(): \n \xa0\xa0\xa0\xa0 errorCode  =   vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0 \xa0 \n def   pause(): \n \xa0\xa0\xa0\xa0 errorCode  =   vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait) \n \xa0 \n def   speed(handle,vel): \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,handle,vel,vrep.simx_opmode_oneshot_wait) \n \xa0 \n def   getballposition(): \n \xa0\xa0\xa0\xa0 #for i in range(steps): \n \xa0\xa0\xa0\xa0 errorCode,position_BR = vrep.simxGetObjectPosition(clientID,BRod_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 errorCode,position_S = vrep.simxGetObjectPosition(clientID,Sphere_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 errorCode,position_RR = vrep.simxGetObjectPosition(clientID,RRod_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 errorCode,RRev_pos = vrep.simxGetJointPosition(clientID,RRev_handle,vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0 errorCode,BRev_pos = vrep.simxGetJointPosition(clientID,BRev_handle,vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0 Bv  = position_S[ 1 ]  -   position_BR[ 1 ] \n \xa0\xa0\xa0\xa0 BBv  = position_S[ 0 ]  -   position_BR[ 0 ] \n \xa0\xa0\xa0\xa0 Rv  = position_S[ 1 ]  -   position_RR[ 1 ] \n \xa0\xa0\xa0\xa0 RRv  = position_S[ 0 ]  -   position_RR[ 0 ] \n \xa0\xa0\xa0\xa0 while   (n  = =   1 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 errorCode,position_BR = vrep.simxGetObjectPosition(clientID,BRod_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 errorCode,position_RR = vrep.simxGetObjectPosition(clientID,RRod_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 errorCode,position_S = vrep.simxGetObjectPosition(clientID,Sphere_handle, - 1 ,vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Rv  = position_S[ 1 ] -   position_RR[ 1 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 RRv  = position_S[ 0 ]  -   position_RR[ 0 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Bv  = position_S[ 1 ] -   position_BR[ 1 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 BRv  = position_S[ 0 ]  -   position_BR[ 0 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 errorCode,RRev_pos = vrep.simxGetJointPosition(clientID,RRev_handle,vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 errorCode,BRev_pos = vrep.simxGetJointPosition(clientID,BRev_handle,vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 RRev_deg  =   (RRev_pos / math.pi) * 180 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 BRev_deg  =   (BRev_pos / math.pi) * 180 \n \xa0 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 try : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'o\' ):  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   keyboard.is_pressed( \'p\' ):\xa0  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'u\' ):\xa0  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,RMo_handle, 0.1 ,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   keyboard.is_pressed( \'i\' ):\xa0  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,RMo_handle, - 0.1 ,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,RMo_handle, 0 ,vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 except : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   position_S[ 0 ] < =   0   and   BRev_deg < =   - 25 :  #球進入擊球區 and 桿子擊出 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   position_BR[ 1 ]< = 0.5 :  #桿子偏右邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BMo_handle,  0.08 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BRev_handle, R_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   position_BR[ 1 ] >  0.5 :  #桿子偏左邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BMo_handle,  - 0.08 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BRev_handle, R_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sleep( 0.2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   position_S[ 0 ] < =   0 \xa0  and \xa0  BRev_deg > = 0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   Bv> =   - 0.01   and   Bv < 0.01 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BRev_handle, B_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BRev_handle ,R_KickBallVel) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elif   position_S[ 0 ] >  0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 speed(BRev_handle,R_KickBallVel) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 MMMB  =   Bv * 2 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait) \n \xa0 \n \xa0 \n vrep.simxSetJointTargetVelocity(clientID,BRev_handle, 0 ,vrep.simx_opmode_oneshot_wait) \n vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait) \n vrep.simxSetJointTargetVelocity(clientID,RMo_handle, 0 ,vrep.simx_opmode_oneshot_wait) \n \xa0 \n start() \n getballposition() \n stop() \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '玩家vs電腦.html'}, {'title': '第十二週-影像辨識尋找球和桿子位置', 'text': '利用影像辨識系統尋找紅方、藍方和綠球的位置。 \n \n 程式利用 https://github.com/nemilya/vrep-api-python-opencv 改編而成 \n vrep設定檔: https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/tablefootball - 0507.ttt \n 程式檔: https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/Image_Detection_RGB.py \n 程式碼: \n import vrep\nimport time\n\nfrom PIL import Image as I\nimport array\n\nimport cv2, numpy\n\n# function based on: \n#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py\ndef track_green_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_green = numpy.array([60-range,100,100])\n    upper_green = numpy.array([60+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_green, upper_green)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\ndef track_blue_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_red = numpy.array([0-range,100,100])\n    upper_red = numpy.array([0+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_red, upper_red)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n    \ndef track_red_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_blue = numpy.array([120-range,100,100])\n    upper_blue = numpy.array([120+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_blue, upper_blue)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\nvrep.simxFinish(-1)\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n  print(\'Connected to remote API server\')\n  # get vision sensor objects\n  res, v0 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n  res, v1 = vrep.simxGetObjectHandle(clientID, \'vs2\', vrep.simx_opmode_oneshot_wait)\n  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)\n  time.sleep(1)\n  while (vrep.simxGetConnectionId(clientID) != -1):\n    # get image from vision sensor \'v0\'\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)\n    if err == vrep.simx_return_ok:\n        image_byte_array = array.array(\'b\', image)\n        #print(image_byte_array)\n        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)\n        img2 = numpy.asarray(image_buffer)\n      # try to find something green\n        ret_green = track_green_object(img2)\n        ret_red = track_red_object(img2)\n        ret_blue = track_blue_object(img2)\n      # overlay rectangle marker if something is found by OpenCV\n        if ret_green:\n            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)\n          # return image to sensor \'v1\'\n        if ret_red:\n            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)\n        if ret_blue:\n            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)\n        img2 = img2.ravel()\n        #print(\'B=\',ret_blue[0],ret_blue[1])\n        #print(\'R=\',ret_red[0],ret_red[1])\n        #print(\'G=\',ret_green[0],ret_green[1])\n        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)\n    elif err == vrep.simx_return_novalue_flag:\n      print("no image yet")\n      pass\n    else:\n      print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID) \n', 'tags': '', 'url': '第十二週-影像辨識尋找球和桿子位置.html'}, {'title': '第十三週-影像辨識機器對打', 'text': '利用影像辨識抓取球與操作桿位置並使之對打， \n 由於影像需要處理時間，所以模擬速度越快抓取位置越不精確。 \n 已知錯誤: \n 如果球打到桿子後方會無法回擊。 \n \n vrep設定檔: tablefootball - 0507.ttt \n 程式檔: Image_Detection_play.py \n 程式碼: \n import vrep\nimport time\n\nfrom PIL import Image as I\nimport array\n\nimport cv2, numpy\n\n# function based on: \n#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py\ndef speed(handle,speed):\n    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)\ndef track_green_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_green = numpy.array([60-range,100,100])\n    upper_green = numpy.array([60+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_green, upper_green)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\ndef track_blue_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_red = numpy.array([0-range,100,100])\n    upper_red = numpy.array([0+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_red, upper_red)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n    \ndef track_red_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_blue = numpy.array([120-range,100,100])\n    upper_blue = numpy.array([120+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_blue, upper_blue)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\nvrep.simxFinish(-1)\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n  print(\'Connected to remote API server\')\n  # get vision sensor objects\n  res, v0 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n  res, v1 = vrep.simxGetObjectHandle(clientID, \'vs2\', vrep.simx_opmode_oneshot_wait)\n  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)\n  err,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\n  err,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\n  err,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\n  err,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\n  err,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n  time.sleep(1)\n  while (vrep.simxGetConnectionId(clientID) != -1):\n    # get image from vision sensor \'v0\'\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)\n    if err == vrep.simx_return_ok:\n        image_byte_array = array.array(\'b\', image)\n        #print(image_byte_array)\n        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)\n        img2 = numpy.asarray(image_buffer)\n      # try to find something green\n        ret_green = track_green_object(img2)\n        ret_red = track_red_object(img2)\n        ret_blue = track_blue_object(img2)\n        #print(\'B=\',ret_blue[1],ret_blue[0])#y軸座標為0 x軸座標為1\n        #print(\'R=\',ret_red[1],ret_red[0])\n        #print(\'G=\',ret_green[1],ret_green[0])\n        if ret_green != None and ret_red != None and ret_blue != None:\n            Bv = float(ret_green[0])-float(ret_blue[0])\n            BBv=float(ret_green[1])-float(ret_blue[1])\n            Rv = float(ret_green[0])-float(ret_red[0])\n            RRv=float(ret_green[1])-float(ret_red[1])\n            if Bv<0.0:\n                speed(BMo_handle,Bv*-0.02)\n            elif Bv>0.0:\n                speed(BMo_handle,Bv*-0.02)\n            else:\n                speed(BMo_handle,0)\n            if Rv<0.0:\n                speed(RMo_handle,Rv*-0.02)\n            elif Rv>0.0:\n                speed(RMo_handle,Rv*-0.02)\n            else:\n                speed(RMo_handle,0)\n            if RRv<-10.0:\n                speed(RRev_handle,-2)\n            elif RRv>-10.0:\n                speed(RRev_handle,2)\n            else:\n                pass\n            if BBv<10.0:\n                speed(BRev_handle,-2)\n            elif BBv>10.0:\n                speed(BRev_handle,2)\n            else:\n                pass\n      # overlay rectangle marker if something is found by OpenCV\n        if ret_green:\n            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)\n          # return image to sensor \'v1\'\n        if ret_red:\n            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)\n        if ret_blue:\n            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)\n        img2 = img2.ravel()\n        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)\n    elif err == vrep.simx_return_novalue_flag:\n      print("no image yet")\n      pass\n    else:\n      print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID) \n \n', 'tags': '', 'url': '第十三週-影像辨識機器對打.html'}, {'title': '第十四週-影像辨識機器對打修正十三週錯誤', 'text': '解決了上週若球至桿子後方將無法回擊的問題 \n 影片: \n \n vrep設定檔: tablefootball - 0507.ttt \n 程式檔: Image_Detection_play_v2.py \n 程式碼: \n import vrep\nimport time\n\nfrom PIL import Image as I\nimport array\n\nimport cv2, numpy\n\n# function based on: \n#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py\ndef speed(handle,speed):\n    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)\n        \ndef track_green_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_green = numpy.array([60-range,100,100])\n    upper_green = numpy.array([60+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_green, upper_green)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\ndef track_blue_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_red = numpy.array([0-range,100,100])\n    upper_red = numpy.array([0+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_red, upper_red)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n    \ndef track_red_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_blue = numpy.array([120-range,100,100])\n    upper_blue = numpy.array([120+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_blue, upper_blue)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n\nvrep.simxFinish(-1)\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n  print(\'Connected to remote API server\')\n  # get vision sensor objects\n  res, v0 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n  res, v1 = vrep.simxGetObjectHandle(clientID, \'vs2\', vrep.simx_opmode_oneshot_wait)\n  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)\n  err,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\n  err,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\n  err,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\n  err,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\n  err,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n  time.sleep(1)\n  while (vrep.simxGetConnectionId(clientID) != -1):\n    # get image from vision sensor \'v0\'\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)\n    if err == vrep.simx_return_ok:\n        image_byte_array = array.array(\'b\', image)\n        #print(image_byte_array)\n        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)\n        img2 = numpy.asarray(image_buffer)\n      # try to find something green\n        ret_green = track_green_object(img2)\n        ret_red = track_red_object(img2)\n        ret_blue = track_blue_object(img2)\n        #print(\'B=\',ret_blue[1],ret_blue[0])#y軸座標為0 x軸座標為1\n        #print(\'R=\',ret_red[1],ret_red[0])\n        #print(\'G=\',ret_green[1],ret_green[0])\n        #\'\'\'\n        if ret_green != None and ret_red != None and ret_blue != None:\n            Bv = float(ret_green[0])-float(ret_blue[0])\n            BBv=float(ret_green[1])-float(ret_blue[1])\n            Rv = float(ret_green[0])-float(ret_red[0])\n            RRv=float(ret_green[1])-float(ret_red[1])\n            if Bv<0.0:\n                speed(BMo_handle,Bv*-0.02)\n            elif Bv>0.0:\n                speed(BMo_handle,Bv*-0.02)\n            else:\n                pass\n                \n                \n            if Rv<0.0:\n                speed(RMo_handle,Rv*-0.02)\n            elif Rv>0.0:\n                speed(RMo_handle,Rv*-0.02)\n            else:\n                pass\n                \n                \n            if  ret_blue[1] >=18 and ret_green[1] <= 17:\n                if ret_green[0] >62.5:\n                    speed(BMo_handle,2)\n                    time.sleep(0.1)\n                    speed(BRev_handle,20)\n                    time.sleep(0.1)\n                    if ret_green[1] != ret_blue[1]:\n                        Bv = float(ret_green[0])-float(ret_blue[0])\n                        if Bv<0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        elif Bv>0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(BRev_handle,2)\n                    \n                elif ret_green[0] <62.5:\n                    speed(BMo_handle,-2)\n                    time.sleep(0.1)\n                    speed(BRev_handle,20)\n                    time.sleep(0.1)\n                    if ret_green[1] != ret_blue[1]:\n                        Bv = float(ret_green[0])-float(ret_blue[0])\n                        if Bv<0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        elif Bv>0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(BRev_handle,2)\n            elif ret_green[0]-ret_blue[0] >= -3 and ret_green[0]-ret_blue[0] <= 3:\n                if BBv<10.0:\n                    speed(BRev_handle,-2)\n                elif BBv>10.0:\n                    speed(BRev_handle,2)\n                else:\n                    pass\n                    \n            \n            if  ret_red[1] <=236 and ret_green[1] >= 237:\n                if ret_green[0] >62.5:\n                    speed(RMo_handle,2)\n                    time.sleep(0.1)\n                    speed(RRev_handle,-20)\n                    time.sleep(0.1)\n                    if ret_green[1] != ret_red[1]:\n                        Rv = float(ret_green[0])-float(ret_red[0])\n                        if Rv<0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        elif Rv>0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(RRev_handle,2)\n                    \n                elif ret_green[0] <62.5:\n                    speed(RMo_handle,-2)\n                    time.sleep(0.1)\n                    speed(RRev_handle,-20)\n                    time.sleep(0.1)\n                    if ret_green[1] != ret_red[1]:\n                        Rv = float(ret_green[0])-float(ret_red[0])\n                        if Rv<0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        elif Rv>0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(RRev_handle,2)\n            elif ret_green[0]-ret_red[0] >= -3 and ret_green[0]-ret_red[0] <= 3:\n                if RRv<-10.0:\n                    speed(RRev_handle,-2)\n                elif RRv>-10.0:\n                    speed(RRev_handle,2)\n                else:\n                    pass\n                    \n            #\'\'\'\n      # overlay rectangle marker if something is found by OpenCV\n        if ret_green:\n            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)\n          # return image to sensor \'v1\'\n        if ret_red:\n            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)\n        if ret_blue:\n            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)\n        img2 = img2.ravel()\n        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)\n    elif err == vrep.simx_return_novalue_flag:\n      print("no image yet")\n      pass\n    else:\n      print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID) \n', 'tags': '', 'url': '第十四週-影像辨識機器對打修正十三週錯誤.html'}, {'title': '第十四週-更改影像辨識方式', 'text': '此程式目前只有尋找藍色物件位置 \n \n import vrep\nimport time\nimport random as rng\nfrom PIL import Image as I\nimport array\n\nimport cv2, numpy\n\n# function based on: \n#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py\ndef speed(handle,speed):\n    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)\n\ndef track_blue_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (3,3),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only blue colors\n    ran = 20\n    lower_blue = numpy.array([0-ran,100,100])\n    upper_blue = numpy.array([0+ran,255,255])\n    # Threshold the HSV image to get only blue colors\n    mask = cv2.inRange(hsv, lower_blue, upper_blue)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    \n    threshold = 100\n    canny_output = cv2.Canny(bmask, threshold,threshold*2)\n    contours, _ = cv2.findContours(canny_output, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    # Get the moments\n    mu = [None]*len(contours)\n    for i in range(len(contours)):\n        mu[i] = cv2.moments(contours[i])\n    # Get the mass centers\n    mc = [None]*len(contours)\n    for i in range(len(contours)):\n        # add 1e-5 to avoid division by zero\n        mc[i] = (mu[i][\'m10\'] / (mu[i][\'m00\'] + 1e-5), mu[i][\'m01\'] / (mu[i][\'m00\'] + 1e-5))\n    return mc\n\nvrep.simxFinish(-1)\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n  print(\'Connected to remote API server\')\n  # get vision sensor objects\n  res, v0 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n  res, v1 = vrep.simxGetObjectHandle(clientID, \'vs2\', vrep.simx_opmode_oneshot_wait)\n  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)\n  err,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\n  err,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\n  err,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\n  err,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\n  err,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n  err,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n  time.sleep(1)\n  while (vrep.simxGetConnectionId(clientID) != -1):\n    # get image from vision sensor \'v0\'\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)\n    if err == vrep.simx_return_ok:\n        image_byte_array = array.array(\'b\', image)\n        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)\n        img2 = numpy.asarray(image_buffer)\n        # try to find something blue\n        ret_blue = track_blue_object(img2)\n        ret_blue_odd = ret_blue[::2]\n        # get the position of blue Object\n        for i in range(len(ret_blue_odd)):\n            if ret_blue_odd[i][1] >=13 and ret_blue_odd[i][1] <=20:\n                blue00 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n                \n            elif ret_blue_odd[i][1] >= 57 and ret_blue_odd[i][1] <=64:\n                if ret_blue_odd[i][0] < ret_blue_odd[i+1][0]:\n                    blue01 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n                elif ret_blue[i][0] >= ret_blue[i+1][0]:\n                    blue02 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n        # blue00 is first rod object position\n        # blue01 is  second rod and left object position\n        # blue02 is second rod and right object position\n        \n        \n        if ret_blue:\n            for i in range(len(ret_blue)):\n                cv2.rectangle(img2,(int(ret_blue[i][0] - 2),int(ret_blue[i][1] - 5)), (int(ret_blue[i][0] + 2),int(ret_blue[i][1] + 5)), (0x33,0xcc,0xff), 1)\n        img2 = img2.ravel()\n        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)\n    elif err == vrep.simx_return_novalue_flag:\n      print("no image yet")\n      pass\n    else:\n      print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID) \n \n', 'tags': '', 'url': '第十四週-更改影像辨識方式.html'}, {'title': '第十五週-影像辨識多個球員踢球', 'text': '判斷第二根桿子上兩個球員誰距離球比較近，會利用較近的球員去踢球。 \n 由於影像輸出後要進行運算，要花費一段時間(可以看影片中的上下兩台攝影機的延遲看出)， \n 所以模擬速度如果調整過快會導致判斷錯誤。 \n \n \n 設定檔: tablefootball - 0601.ttt \n 程式碼: \n import vrep\nimport time\nimport random as rng\nfrom PIL import Image as I\nimport array\nimport math\nimport cv2, numpy\n\n\ndef speed(handle,speed):\n    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)\n\n#影像尋找藍色物件\ndef track_blue_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (3,3),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only blue colors\n    ran = 20\n    lower_blue = numpy.array([0-ran,100,100])\n    upper_blue = numpy.array([0+ran,255,255])\n    # Threshold the HSV image to get only blue colors\n    mask = cv2.inRange(hsv, lower_blue, upper_blue)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    threshold = 100\n    canny_output = cv2.Canny(bmask, threshold,threshold*2)\n    contours, _ = cv2.findContours(canny_output, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    # Get the moments\n    mu = [None]*len(contours)\n    for i in range(len(contours)):\n        mu[i] = cv2.moments(contours[i])\n    # Get the mass centers\n    mc = [None]*len(contours)\n    for i in range(len(contours)):\n        mc[i] = (mu[i][\'m10\'] / (mu[i][\'m00\']), mu[i][\'m01\'] / (mu[i][\'m00\']))\n    return mc\n#影像尋找紅色物件\ndef track_red_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (3,3),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only blue colors\n    ran = 15\n    lower_red = numpy.array([120-ran,100,100])\n    upper_red = numpy.array([120+ran,255,255])\n    # Threshold the HSV image to get only blue colors\n    mask = cv2.inRange(hsv, lower_red, upper_red)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    \n    threshold = 100\n    canny_output = cv2.Canny(bmask, threshold,threshold*2)\n    contours, _ = cv2.findContours(canny_output, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    # Get the moments\n    mu = [None]*len(contours)\n    for i in range(len(contours)):\n        mu[i] = cv2.moments(contours[i])\n    # Get the mass centers\n    mc = [None]*len(contours)\n    for i in range(len(contours)):\n        # add 1e-5 to avoid division by zero\n        mc[i] = (mu[i][\'m10\'] / (mu[i][\'m00\'] ), mu[i][\'m01\'] / (mu[i][\'m00\']))\n    return mc\n#影像尋找綠色物件\ndef track_green_object(image):\n    # Blur the image to reduce noise100\n    blur = cv2.GaussianBlur(image, (5,5),0)\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)\n    # Threshold the HSV image for only green colors\n    range = 15\n    lower_green = numpy.array([60-range,100,100])\n    upper_green = numpy.array([60+range,255,255])\n    # Threshold the HSV image to get only green colors\n    mask = cv2.inRange(hsv, lower_green, upper_green)\n    # Blur the mask\n    bmask = cv2.GaussianBlur(mask, (5,5),0)\n    # Take the moments to get the centroid\n    moments = cv2.moments(bmask)\n    m00 = moments[\'m00\']\n    centroid_x, centroid_y = None, None\n    if m00 != 0:\n        centroid_x = int(moments[\'m10\']/m00)\n        centroid_y = int(moments[\'m01\']/m00)\n    # Assume no centroid\n    ctr = None\n    # Use centroid if it exists\n    if centroid_x != None and centroid_y != None:\n        ctr = (centroid_x, centroid_y)\n    return ctr\n    \nvrep.simxFinish(-1)\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nblue00=blue10=blue11=blue20=blue21=blue22=blue30=blue31=blue32=None\nred00=red10=red11=red20=red21=red22=red30=red31=red32=None\nKickBallV =360   \nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!=-1:\n  print(\'Connected to remote API server\')\n  # get vision sensor objects\n  res, v0 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n  res, v1 = vrep.simxGetObjectHandle(clientID, \'vs2\', vrep.simx_opmode_oneshot_wait)\n  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)\n  err,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\n  err,BRev0_handle=vrep.simxGetObjectHandle(clientID,\'BRev0\',vrep.simx_opmode_oneshot_wait)\n  err,BRev1_handle=vrep.simxGetObjectHandle(clientID,\'BRev1\',vrep.simx_opmode_oneshot_wait)\n  err,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\n  err,BMo0_handle=vrep.simxGetObjectHandle(clientID,\'BMo0\',vrep.simx_opmode_oneshot_wait)\n  err,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\n  err,RRev0_handle=vrep.simxGetObjectHandle(clientID,\'RRev0\',vrep.simx_opmode_oneshot_wait)\n  err,RRev1_handle=vrep.simxGetObjectHandle(clientID,\'RRev1\',vrep.simx_opmode_oneshot_wait)\n  err,RMo0_handle=vrep.simxGetObjectHandle(clientID,\'RMo0\',vrep.simx_opmode_oneshot_wait)\n  err,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n  time.sleep(1)\n  while (vrep.simxGetConnectionId(clientID) != -1):\n    # get image from vision sensor \'v0\'\n    blue00_pos=blue10_pos=blue11_pos=blue20_pos=blue21_pos=blue22_pos=blue30_pos=blue31_pos=blue32_pos=None\n    red00_pos=red10_pos=red11_pos=red20_pos=red21_pos=red22_pos=red30_pos=red31_pos=red32_pos=None\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)\n    if err == vrep.simx_return_ok:\n        image_byte_array = array.array(\'b\', image)\n        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)\n        img2 = numpy.asarray(image_buffer)\n        ret_blue = track_blue_object(img2)\n        ret_red = track_red_object(img2)\n        ret_green = track_green_object(img2)\n        \n        if ret_green != None:\n            #各球員座標命名方式\n            # blue(x)(y) x = 第幾根桿子(0~3) y = 左邊數來第幾個人(0~2)\n            # red(x)(y) x = 第幾根桿子(0~3) y = 左邊數來第幾個人(0~2)\n            #刪除重複的座標\n            times_of_del_ret_blue = int(len(ret_blue)/2)\n            times_of_del_ret_red = int(len(ret_red)/2)\n            #times_of_del_ret_green = int(len(ret_green)/2)\n            for i in range(0,times_of_del_ret_blue):\n                if ret_blue[i][1] - ret_blue[i+1][1] <= 1:\n                    del ret_blue[i]\n            for i in range(0,times_of_del_ret_red):\n                if ret_red[i][1] - ret_red[i+1][1] <= 1:\n                    del ret_red[i]\n            #藍球員座標命名\n            for i in range(len(ret_blue)):\n                if ret_blue[i][1] >=10 and ret_blue[i][1] <=25:\n                    blue00 = (ret_blue[i][0], ret_blue[i][1])\n                elif ret_blue[i][1] >= 40 and ret_blue[i][1] <=70:\n                    blue10_pos = (ret_blue[i][0], ret_blue[i][1])\n                    if blue11_pos== None:\n                        blue11_pos= (ret_blue[i][0], ret_blue[i][1])\n                elif ret_blue[i][1] >=90 and ret_blue[i][1] <=130:\n                    if blue20_pos == None:\n                        if blue22_pos == None:\n                            blue22_pos = (ret_blue[i][0], ret_blue[i][1])\n                        elif blue21_pos == None:\n                            blue21_pos = (ret_blue[i][0], ret_blue[i][1])\n                        elif blue20_pos == None:\n                            blue20_pos = (ret_blue[i][0], ret_blue[i][1])\n                elif ret_blue[i][1] >=140 and ret_blue[i][1] <=180:\n                    if blue30_pos == None:\n                        if blue32_pos == None:\n                            blue32_pos = (ret_blue[i][0], ret_blue[i][1])\n                        elif blue31_pos == None:\n                            blue31_pos = (ret_blue[i][0], ret_blue[i][1])\n                        elif blue30_pos == None:\n                            blue30_pos = (ret_blue[i][0], ret_blue[i][1])\n            #藍球員10和11座標排列\n            if blue10_pos[0] < blue11_pos[0]:\n                blue10 = blue10_pos\n                blue11 = blue11_pos\n            elif blue10_pos[0] > blue11_pos[0]:\n                blue10 = blue11_pos\n                blue11 = blue10_pos\n            #紅球員座標命名\n            for i in range(len(ret_red)):\n                if ret_red[i][1] >=230 and ret_red[i][1] <=250:\n                    red00 = (ret_red[i][0], ret_red[i][1])\n                elif ret_red[i][1] >= 185 and ret_red[i][1] <=205:\n                    red10_pos = (ret_red[i][0], ret_red[i][1])\n                    if red11_pos == None:\n                        red11_pos = (ret_red[i][0], ret_red[i][1])\n                elif ret_red[i][1] >=134 and ret_red[i][1] <=154:\n                    if red21_pos == None:\n                        if red22_pos == None:\n                            red22_pos = (ret_red[i][0], ret_red[i][1])\n                        elif red20_pos == None:\n                            red20_pos = (ret_red[i][0], ret_red[i][1])\n                        elif red21_pos == None:\n                            red21_pos = (ret_red[i][0], ret_red[i][1])\n                elif ret_red[i][1] >=80 and ret_red[i][1] <=100:\n                    if red30_pos == None:\n                        if red32_pos == None:\n                            red32_pos = (ret_red[i][0], ret_red[i][1])\n                        elif red31_pos == None:\n                            red31_pos = (ret_red[i][0], ret_red[i][1])\n                        elif red30_pos == None:\n                            red30_pos = (ret_red[i][0], ret_red[i][1])\n            #紅球員10和11座標排列\n            if red10_pos[0] < red11_pos[0]:\n                red10 = red10_pos\n                red11 = red11_pos\n            elif blue10_pos[0] > blue11_pos[0]:\n                red10 = red11_pos\n                red11 = red10_pos\n    #------------------------------對打程式開始------------------------------\n            Bv = ret_green[0] - blue00[0]\n            BBv=ret_green[1] - blue00[1]\n            Rv = ret_green[0] - red00[0]\n            RRv=ret_green[1] - red00[1]\n            #藍守門員移動\n            if Bv<0.0:\n                speed(BMo_handle,Bv*-0.02)\n            elif Bv>0.0:\n                speed(BMo_handle,Bv*-0.02)\n            else:\n                pass\n            #紅守門員移動\n            if Rv<0.0:\n                speed(RMo_handle,Rv*-0.02)\n            elif Rv>0.0:\n                speed(RMo_handle,Rv*-0.02)\n            else:\n                pass\n            #藍桿一移動\n            B10v = ret_green[0] - blue10[0]\n            B11v = ret_green[0] - blue11[0]\n            if abs(B10v) <= abs(B11v):\n                if ret_green[0] < 147 :\n                    if B10v < 0:\n                        speed(BMo0_handle,B10v*-0.02)\n                    elif B10v > 0:\n                        speed(BMo0_handle,B10v*-0.02)\n                    else:\n                        pass\n                else:\n                    speed(BMo0_handle,0.5)\n            elif abs(B10v) > abs(B11v):\n                if ret_green[0] >108:\n                    if B11v < 0:\n                        speed(BMo0_handle,B11v*-0.02)\n                    elif B11v > 0:\n                        speed(BMo0_handle,B11v*-0.02)\n                    else:\n                        pass\n                else:\n                    speed(BMo0_handle,-0.5)\n            #紅桿一移動\n            R10v = ret_green[0] - red10[0]\n            R11v = ret_green[0] - red11[0]\n            if abs(R10v) <= abs(R11v):\n                if ret_green[0] < 147 :\n                    if R10v < 0:\n                        speed(RMo0_handle,R10v*-0.02)\n                    elif R10v > 0:\n                        speed(RMo0_handle,R10v*-0.02)\n                    else:\n                        pass\n                else:\n                    speed(BMo0_handle,0.5)\n            elif abs(R10v) > abs(R11v):\n                if ret_green[0] >108:\n                    if R11v < 0:\n                        speed(RMo0_handle,R11v*-0.02)\n                    elif R11v > 0:\n                        speed(RMo0_handle,R11v*-0.02)\n                    else:\n                        pass\n                else:\n                    speed(RMo0_handle,-0.5)\n            #藍守門員踢球\n            if  blue00[1] >=18 and ret_green[1] <= 17:\n                if ret_green[0] >62.5:\n                    speed(BMo_handle,2)\n                    time.sleep(0.1)\n                    speed(BRev_handle,20)\n                    time.sleep(0.1)\n                    if ret_green[1] != blue00[1]:\n                        Bv = ret_green[0]-blue00[0]\n                        if Bv<0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        elif Bv>0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(BRev_handle,2)\n                    \n                elif ret_green[0] <62.5:\n                    speed(BMo_handle,-2)\n                    time.sleep(0.1)\n                    speed(BRev_handle,20)\n                    time.sleep(0.1)\n                    if ret_green[1] != blue00[1]:\n                        Bv = ret_green[0] - blue00[0]\n                        if Bv<0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        elif Bv>0.0:\n                            speed(BMo_handle,Bv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(BRev_handle,2)\n            elif ret_green[0] - blue00[0] >= -3 and ret_green[0] - blue00[0] <= 3:\n                if BBv<10.0:\n                    speed(BRev_handle,-2)\n                elif BBv>10.0:\n                    speed(BRev_handle,2)\n                else:\n                    pass\n            #紅守門員踢球   \n            if  red00[1] <=236 and ret_green[1] >= 237:\n                if ret_green[0] >62.5:\n                    speed(RMo_handle,2)\n                    time.sleep(0.1)\n                    speed(RRev_handle,-20)\n                    time.sleep(0.1)\n                    if ret_green[1] != ret_red[1]:\n                        Rv = ret_green[0] - red00[0]\n                        if Rv < 0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        elif Rv>0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(RRev_handle,2)\n                    \n                elif ret_green[0] <62.5:\n                    speed(RMo_handle,-2)\n                    time.sleep(0.1)\n                    speed(RRev_handle,-20)\n                    time.sleep(0.1)\n                    if ret_green[1] != red00[1]:\n                        Rv = ret_green[0] - red00[0]\n                        if Rv<0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        elif Rv>0.0:\n                            speed(RMo_handle,Rv*-0.02)\n                        else:\n                            pass\n                    else:\n                        speed(RRev_handle,2)\n            elif ret_green[0] - red00[0] >= -3 and ret_green[0] - red00[0] <= 3:\n                if RRv<-10.0:\n                    speed(RRev_handle,-2)\n                elif RRv>-10.0:\n                    speed(RRev_handle,2)\n                else:\n                    pass\n            #藍桿一踢球\n            if ret_green[1] <= 70 and ret_green[1] >= 55:\n                speed(BRev0_handle,B_KickBallVel)\n                speed(BRev1_handle,B_KickBallVel)\n            else:\n                speed(BRev0_handle,R_KickBallVel)\n                speed(BRev1_handle,R_KickBallVel)\n            #紅桿一踢球\n            if ret_green[1] <= 202 and ret_green[1] >= 187:\n                speed(RRev0_handle,R_KickBallVel)\n                speed(RRev1_handle,R_KickBallVel)\n            else:\n                speed(RRev0_handle,B_KickBallVel)\n                speed(RRev1_handle,B_KickBallVel)\n        #對打程式結束\n        #影像加框處理\n        if ret_blue:\n            for i in range(len(ret_blue)):\n                cv2.rectangle(img2,(int(ret_blue[i][0] - 2),int(ret_blue[i][1] - 5)), (int(ret_blue[i][0] + 2),int(ret_blue[i][1] + 5)), (0x33,0xcc,0xff), 1)\n        if ret_red:\n            for i in range(len(ret_red)):\n                cv2.rectangle(img2,(int(ret_red[i][0] - 2),int(ret_red[i][1] - 5)), (int(ret_red[i][0] + 2),int(ret_red[i][1] + 5)), (0xff,0x33,0x33), 1)\n        if ret_green:\n            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)\n        img2 = img2.ravel()\n        #影像回傳\n        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)\n    elif err == vrep.simx_return_novalue_flag:\n      print("no image yet")\n      pass\n    else:\n      print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID) \n \n', 'tags': '', 'url': '第十五週-影像辨識多個球員踢球.html'}, {'title': '系統功能問題與討論', 'text': "問題: \n 第十三週-影像辨識機器對打 \n 如果球打到桿子後方會無法回擊 \n 解決方法: \n 更改判斷球位置的方式如 第十四週內容 \n 問題: \n 無法判別多根桿子 \n 原因: \n 程式會尋找所有藍色物件的質心 \n 解決方法: \n 更改尋找物件方式 \n 由原本的找尋藍色物件改成尋找藍色物件的輪廓 \n 問題: \n 由於尋找物件 輪廓順序是隨機的 \n 所以無法直接給予相對應物件座標位置 \n 解決方法: \n 新增以下判斷式來設定各物件位置變數 \n # 只取奇數項\nret_blue_odd = ret_blue[::2]\nfor i in range(len(ret_blue_odd)):\n    if ret_blue_odd[i][1] >=13 and ret_blue_odd[i][1] <=20:\n        blue00 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n                 \n    elif ret_blue_odd[i][1] >= 57 and ret_blue_odd[i][1] <=64:\n        if ret_blue_odd[i][0] < ret_blue_odd[i+1][0]:\n            blue01 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n        elif ret_blue[i][0] >= ret_blue[i+1][0]:\n            blue02 = (ret_blue_odd[i][0], ret_blue_odd[i][1])\n# blue00 is first rod object position\n# blue01 is  second rod and left object position\n# blue02 is second rod and right object position \n 問題: \n 同時按下兩個鍵會造成衝突 \n 解決方法 : \n 將兩桿子操作按鍵，使用try except分開寫成兩段程式 \n try:\nif keyboard.is_pressed('v'):\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('b'):\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('z'):\nvrep.simxSetJointTargetVelocity(clientID,BMo_handle,0.2,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('x'):\nvrep.simxSetJointTargetVelocity(clientID,BMo_handle,0,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('c'):\nvrep.simxSetJointTargetVelocity(clientID,BMo_handle,-0.2,vrep.simx_opmode_oneshot_wait)\nexcept:\nbreak \ntry:\nif keyboard.is_pressed('o'): \nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('p'): \nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('y'): \nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.2,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('u'): \nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('i'): \nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.2,vrep.simx_opmode_oneshot_wait)\nexcept:\nbreak \n 問題: \n 操作按鍵過多，導致控制困難 \n 解決方法 : \n 取消暫停鍵 \n 改成按下按鍵作動 放開則停止 \n 修改前 : \n if keyboard.is_pressed('y'): #桿子向左移\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.1,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('u'): #桿子停止作動\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('i'): #桿子向右移\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.1,vrep.simx_opmode_oneshot_wait) \n 修改後 : \n \n if keyboard.is_pressed('u'): #桿子向左移\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.1,vrep.simx_opmode_oneshot_wait)\nelif keyboard.is_pressed('i'): #桿子向右移\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.1,vrep.simx_opmode_oneshot_wait)\nelse:\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\n \n", 'tags': '', 'url': '系統功能問題與討論.html'}, {'title': '結案報告', 'text': '', 'tags': '', 'url': '結案報告.html'}, {'title': '專案口頭簡報', 'text': '', 'tags': '', 'url': '專案口頭簡報.html'}, {'title': '專案報告書', 'text': '', 'tags': '', 'url': '專案報告書.html'}, {'title': '如何開始編輯報告書', 'text': '可參考: https://mdecp2018.github.io/finalproject-bgx/content/Kmol-editor.html \n 首先下載: miktex_portable_and_pandoc.7z \n 下載完成後解壓縮至隨身系統中(y槽中) \n 完成後會多出兩個資料夾 \n 分別是 pandoc-2.4-windows-x86_64 和\xa0miktex_portable \n 接著用SciTE 開啟start.bat \n 並在path=的最後方新增 \n %Disk%:\\pandoc-2.4-windows-x86_64;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin; \n 接著在cmd (小黑窗) 中輸入 \n python -m pip install pandoc-fignos pandoc-tablenos pandoc-eqnos \n 等他安裝完成 \n 完成後重新啟動可攜系統即可 \n', 'tags': '', 'url': '如何開始編輯報告書.html'}, {'title': '編輯報告書須知', 'text': '首次使用 \n 報告書相關檔案位於 \n cd2019a-task1-2019cda_t1_g3_1/report \n 首次開始編輯時先至 report/user中複製user.leo並改為(自己的學號).leo \n 之後要編輯請開啟自己的.leo檔 \n 如何建立新的章節 \n \xa0章節內容 > @path paragraph > 點選任意章節 \n 按下 Ctrl + i \n 並把新增的分頁命名為@clean 檔案名稱.md \n 建議取成英文名稱且一眼就看的出來是哪篇章節的 \n 完成後到最上端尋找@button Report pdf的頁籤 \n 並在約29行的位置 如圖 \n \n "檔案名稱.md" \n 如果有哪一個章節暫時不需要可以在該章節最前端新增 # \n leo editer常用快速鍵 \n Ctrl + i 建立新頁籤 \n Ctrl + r\xa0頁籤往右移 \n Ctrl + l\xa0頁籤往左移 \n Ctrl + u\xa0頁籤往上移 \n Ctrl + d\xa0頁籤往下移 \n \n', 'tags': '', 'url': '編輯報告書須知.html'}, {'title': '第十週', 'text': '', 'tags': '', 'url': '第十週.html'}, {'title': '手足球', 'text': '圖檔位置: \n https://cad.onshape.com/documents/0bfaa15bd19b1324aaa7e507/w/04eb23a61d6467f8c87c3a8e/e/ecd14e928fc285a5eb479e63 \n 藉由 建立手足球系統來更加熟悉vrep的各項設定與操作 \n', 'tags': '', 'url': '手足球.html'}, {'title': '足球自動回擊', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python原始碼: \n import vrep\nfrom time import sleep\nimport sys, math\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90      #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef getballposition():\n    errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    vv =position_D[1] - position_P[1]\n    vvv =position_D[2] - position_P[2]\n    while (n == 1):\n        \n        if vv <= 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n            \n        elif vv <= 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,vv,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop()\n\n\n\n\n\n \n ＿ \n', 'tags': '', 'url': '足球自動回擊.html'}, {'title': '手足球雙人對打', 'text': '\n vrep檔案位置: tablefootball.ttt \n python控制程式 \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90    \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        try:\n            if keyboard.is_pressed(\'v\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'b\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'z\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'x\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'c\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            \n            elif keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'y\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            else:\n                pass\n        except:\n            break \n        MMMB = Bv*2\n        MMMR = Rv*2\n    vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球雙人對打.html'}, {'title': '手足球電腦對電腦', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python控制程式: \n import vrep\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 45     #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    #for i in range(steps):\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[0] - position_RR[0]\n    while (n == 1):\n        \n        if Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        else:\n                pass\n        MMMB = Bv*1.2 \n        MMMR = Rv*1.2\n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n        vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n        #print(BBv)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球電腦對電腦.html'}, {'title': '手足球手控與電腦對打', 'text': '\n vrep檔案位置: tablefootball.ttt \n python原始碼: \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90    \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[2]-position_S[2]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        if Bv <= 0 and BBv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n         \n        elif Bv > 0 and BBv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n             \n        elif Bv <= 0 and BBv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n         \n        elif Bv > 0 and BBv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n        \n        try:\n            if keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'y\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            else:\n                pass\n        except:\n            break \n            \n        \n        MMMB = Bv*2\n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球手控與電腦對打.html'}, {'title': '手足球問題與解決方案', 'text': '手足球問題一 \n 如何知道目前的球的位置? \n 解決方法: \n 運用指令 \n number returnCode,number parentObjectHandle=vrep.simxGetObjectParent(number clientID,number objectHandle,number operationMode) \n 來得到目前座標 \n \n 手足球問題二 \n 如何讓回擊的桿子偵測球的位置進行移動? \n 解決方法: \n 利用指令得到球與桿子的y方向座標之後 \n 利用相減所得到的值可以知道球在桿子的左邊或是右邊 \n \n 手足球問題三 \n 直接給定桿子橫向移動的速度為0.5m/s \n 會讓他產生速度從0瞬間變 0.5m/s 的現象 \n 解決方法: \n 把給定的速度更改為桿子與球座標的差值 \n 手足球問題四 \n 如果球速過快直接穿過電腦控制的那邊的桿子 \n 會造成把球卡回牆邊不會回擊 \n 解決方法: \n \n', 'tags': '', 'url': '手足球問題與解決方案.html'}, {'title': '參考資料', 'text': 'http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm \n', 'tags': '', 'url': '參考資料.html'}, {'title': '如何使用Python Remote API', 'text': '首先完成vrep的模擬設定 \n 再來對著要新增程式的物件點選右鍵 →add→ Associated child script →threaded \n 會多出如下圖的圖示 \n \n 點開上圖紅框內左邊的圖示並輸入以下程式碼 \n threadFunction=function()\n\nsim.setThreadSwitchTiming(2) -- Default timing for automatic thread switching\n\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\n    if not res then\n\tsim.addStatusbarMessage(\'Lua runtime error: \'..err)\n    end\n\n-- Put some clean-up code here:\nsimRemoteApi.start(19997)\nend\n \n   \n 到V-REP資料夾 → programming → remoteApiBindings → python → python中 \n 複製vrep.py和vrepConst.py \n 跟programming → remoteApiBindings → lib → lib → Windows → 64Bit中 \n 複製remoteApi.dll到 你要存程式的資料夾中 \n 打開wscite並輸入以下程式碼 \n import vrep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\') \n 存成 → 檔名.py \n 並執行 \n 如果執行結果為 \n Connected to remote server >Exit code: 0 \n 那就可以開始編寫程式了 \n', 'tags': '', 'url': '如何使用Python Remote API.html'}, {'title': '課程內容整理', 'text': '', 'tags': '', 'url': '課程內容整理.html'}, {'title': '隨身系統', 'text': '藉由自行製作隨身系統，來了解隨身系統的運作方式，以便了解工具的使用與設定，並可以量身打造所需的隨身系統。 \n 創建資料夾 \n 創建一個放置可攜檔案的資料夾 \n 並在裡面 創建一個data資料夾用來連結y槽 \n SciTE \n 安裝SciTE至data資料夾中 \n 使用windos的   full download版本 \n SciTE Download: https://www.scintilla.org/SciTEDownload.html \n 打開SciTE後 \n 開啟設定檔案 \n \n 利用ctrl+f找到code.page並改為下圖所示 \n \n 安裝 python 進可攜系統 \n 安裝時選取自訂義安裝 \n \n 勾選所需要的項目 \n \n \n 設定安裝位置 \n \n 利用 HxD 二位元編輯器設定C:\\p37\\Scripts\\pip.exe \n 使用ctrl+f功能尋找c :\\p37並改為y:\\p37 \n 如紅字處 \n \n \n 更改完成後就可以把整個p37資料夾移至data資料夾 \n start.bat \n 利用安裝的SciTE製作start.bat檔案 \n \n stop.bat \n 利用安裝的SciTE製作stop.bat檔案 \n \n Kdiff3 \n 在製作過程中想要快速了解兩個檔案之間的差異可以使用Kdiff3來快速比對出不一樣的地方。 \n Kdiff3:  http://kdiff3.sourceforge.net/ \n', 'tags': '', 'url': '隨身系統.html'}, {'title': 'Git - ungit', 'text': '使用圖形化介面讓使用者更加了解目前所在的分支與倉儲狀況 \n 如何安裝 \n 參考連結 http://mde.tw/wcm2019/content/%E5%AF%A6%E7%BF%92%E9%A0%85%E7%9B%AE%E4%BA%8C.html \n 至上方連結處下載   nodejs_with_ungit.7z \n 下載完成後解壓縮到隨身系統資料夾的data中 \n 並在start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n set path8=%Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm; \n %path8%; \n 如下圖 \n \n \n 之後在中空白的SciTE中輸入 \n ungit --launchBrowser=0 --launchCommand "C:\\PROGRA~2\\Google\\Chrome\\Application\\chrome.exe %%U" \n 存檔至Data中並命名為kungit.bat \n', 'tags': '', 'url': 'Git - ungit.html'}, {'title': 'ssh金鑰', 'text': '參考連結: https://2019wcm.blogspot.com/2019/03/github-github-pages.html \n 關閉跳出式登入窗 \n 首先 使用 git config --edit --system \n 叫出vi 編輯器,編輯git的設定檔案 \n 使用按鍵H,J,K,L控制上下左右 \n 案a進入編輯模式 \n 編輯模式最底下會顯示 \n -- INSERT -- \n 就可以按BACKSPACE刪除最後一行如下圖 \n \n 刪除後按ESC鍵離開編輯模式 \n 再輸入冒號後，再輸入wq存檔並關閉。 \n 如果要直接離開則輸入exit \n 製作金鑰 \n 在 可攜系統的命令列視窗輸入sh或者是sh_yen(可至y:\\git\\bin中確認) \n 執行 Git 的 shell \n 並輸入 \n ssh-keygen -t rsa -b 4096 -C "This is my key" \n 將會建立Private 與 Public 金鑰至y:\\home\\.ssh\\id_rsa與id_rsa.pub \n 將 id_rsa.pub 的內容複製轉貼至Github 帳號的settings如下圖位置 \n \n \n \n 在SSH and GPG keys的SSH Key新建並貼上複製內容 \n 利用SSH提交推送 \n 首先要確認倉儲是以SSH的方式clone的 \n 利用以下指令clone或 \n git clone  git@github.com:倉儲擁有者/ 倉儲名 \n 或是直接利用SciTE開啟倉儲的.git檔案裡面的config \n 把url = https://github.com/ 倉儲擁有者/ 倉儲名 \n 改成url = git@github.com: 倉儲擁有者/ 倉儲名 \n 之後直接提交推送就可以不用打帳號密碼了 \n', 'tags': '', 'url': 'ssh金鑰.html'}, {'title': 'git', 'text': 'Plumbing and Porcelain \n Plumbing and Porcelain \n \n \n \n Git Objects \n Git Objects \n cat -file 從Git 取回資料 \n update - ref更新引用 \n Git References \n Git References \n 如何知道最後一次提交？ : \n 執行 git branch  \n $ cat .git/HEAD  \n ref: refs/heads/master \n 執行 git checkout test \n $ cat .git/HEAD  \n ref: refs/heads/test \n 手動編輯此文件，但同樣可以執行更安全的命令: \n 執行symbolic-ref \n $ git symbolic-ref HEAD  \n refs/heads/master \n 設置HEAD: \n $ git symbolic-ref HEAD  refs/heads/test  \n $ cat .git/HEAD  \n ref: refs/heads/test \n \n \n \n Packfiles \n Packfiles 使用 git cat-file 命令查看這個文件大小 \n $ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 22044 \n 使用git gc打包文件 \n $ git gc Counting objects: 18, done. Delta compression using up to 8 threads. Compressing objects: 100% (14/14), done. Writing objects: 100% (18/18), done. Total 18 (delta 3), reused 0 (delta 0) \n \n The Refspec \n The Refspec \n .git / config文件中添加遠端origin的名稱，遠程存儲庫的URL以及用於獲取的refspec \n [remote "origin"] url = https://github.com/schacon/simplegit-progit fetch = +refs/heads/ :refs/remotes/origin/ 如果想一次性執行某些操作，也可以在命令行中指定refspec \n $ git fetch origin master:refs/remotes/origin/mymaster 指定多個refspec \n $ git fetch origin master:refs/remotes/origin/mymaster \\\n\t topic:refs/remotes/origin/topic\nFrom git@github.com:schacon/simplegit\n ! [rejected]        master     -> origin/mymaster  (non fast forward)\n * [new branch]      topic      -> origin/topic 刪除 refspec git push origin :topic git push origin -- delete topic \n Transfer Protocols \n Transfer Protocols \n Transfer Protocols--傳輸協議 \n Git可以透過兩種主要方式在兩個倉儲之間傳輸數據：“啞吧”協議與“智能”協議。 本章重點著重於介紹這兩個主要協議的運作方式。 \n The Dumb Protocol--啞巴協議 \n 該協議稱為“啞巴協議”，是因為它在傳輸過程中不需要服務端的Git特定代碼; 獲取過程是一系列HTTP  GET 請求，使用者可以自由的呈現Git倉儲的安排。 \n \n Maintenance and Data Recovery \n Maintenance and Data Recovery \n 本章重點在介紹Git內部的維護和數據的恢復，有時Git會自動執行一個名為“auto  gc ”的指令，大多數情況下，指令不執行操作，但如果有過多的packfiles，則Git會執行git gc的指令，指令會刪除不必要的文件。 \n 當需要恢復檔案時 可使用git long和git master兩個指令來進行恢復。 \n \n Environment Variables \n Environment Variables \n Git在 bash shell中運行，並使用許多shell環境變量來確定它的行為方式。 \n GIT_EXEC_PATH： 可透過運行檢查當前設置 git --exec-path 。 \n HOME： 它是Git查找全局配置文件的地方。 \n GIT_CONFIG_NOSYSTEM： 如果您的系統配置干擾了您的指令，但是您無權更改或刪除它，這將非常有用。 \n 設置提交者的名字:  GIT_COMMITTER_NAME \n \n “提交者”字段的電子郵件地址:  GIT_COMMITTER_EMAIL \n \n \n \n 用於“提交者”字段中的日期:  GIT_COMMITTER_DATE \n \n \n Summy \n Summary \n 功能很強的系統工具-Git \n 可以輕鬆使用它作為VCS。本章介紹了許多管道指令 - 這些指令使用戶在使用上更家簡單。 \n A3 \n git config \n 該 git config 命令幾乎已在本書的每一章中使用 \n 在初次設置Git中， 我們在開始使用Git之前用它來指定我們的名字，電子郵件地址和編輯器首選項 \n git init \n 我們使用此命令在“將空白倉儲放到 服務器上”中為服務器創建一個空的空白倉儲。 gitstatus \n 該 git status 命令將顯示工作目錄和暫存區域中文件的不同狀態。 哪些文件已修改和未分階段，哪些文件已暫存但尚未提交。 在它的正常形式中，它還將向您展示如何在這些階段之間移動文件的一些基本提示。 \n git diff \n 當您想要查看任意兩棵樹之間的差異時，將使用該命令。 這可能是您的工作環境和臨時區域（單獨 git diff ），暫存區域和上次提交（ git diff --staged ）之間，或兩個提交（ git diff master branchB ） 之間的差異 。 \n git difftool \n 只是啟動一個外部工具，以顯示兩棵樹之間的區別，以防您想使用內置 git diff 命令 之外的其他內容 。 \n \n git reset 主要用於撤消操作，您可以通過動詞來判斷。它在 HEAD 指針 周圍移動 並可選地更改 index 或暫存區域，如果使用，還可以選擇更改工作目錄 。 如果使用不當，此最終選項可能會導致此命令丟失，因此請確保在使用之前了解它。 \n git rm \n 用於從登台區域和Git的工作目錄中刪除文件。它類似於 git add 它為下一次提交分階段刪除文件。 \n git mv \n 是一個簡單的便捷命令，用於移動文件，然後 git add 在新文件和 git rm 舊文件上運行。 我們只 在移動檔案中 簡要提一下這個命令 。 \n git mergetool \n \n \n \n 該 git mergetool 命令只是啟動一個外部合併幫助程序，以防您在Git中遇到合併題。 \n \n \n \n git stash \n \n 用於臨時存儲未提交的工作，以便清除工作目錄，而無需在分支上提交未完成的工作。 這基本上完全涵蓋在 Stashing和Cleaning中。 \n \n \n \n \n A3-1 \n git tag \n \n 該 git tag 命令用於為代碼歷史記錄中的特定點提供永久書籤。 通常，這用於發布容。 \n \n \n \n \n git fetch \n \n \n \n 該 git fetch 命令與遠程存儲庫通信，並獲取該存儲庫中當前不存在的所有信息，並將其存儲在本地數據庫中。 \n \n \n \n \n \n git remote \n \n \n \n 該 git remote 命令是用於記錄遠程存儲庫的管理工具。它允許您將長URL保存，例如“origin”，這樣您就不必一直輸出它們。您可以使用其中的幾個，該 git remote 命令用於添加，更改和刪除它們。 \n \n \n \n \n \n git archive \n \n \n \n 該 git archive 命令用於創建項目特定快照的存檔文件。 我們 git archive 用來創建一個項目的tarball，用於在 準備釋出一個版本中 進行共享。 \n \n \n \n \n \n git submodule \n \n \n \n 該 git submodule 命令用於管理正常存儲庫中的外部存儲庫。這可能適用於庫或其他類型的共享資源。該 submodule 命令具有若干子命令（ add ， update ， sync ，等），用於管理這些資源。 \n \n \n \n \n git show \n \n \n \n \n 該 git show 命令可以以簡單且可讀的方式顯示Git對象。 通常，您可以使用它來顯示有關標記或提交的信息。 \n \n \n \n \n git shortlog \n \n \n \n 該 git shortlog 命令用於匯總輸出 git log 。該命令將採用許多相同的選項， git log 但它不會列出所有提交，而是顯示按作者分組的提交的摘要。 \n \n \n \n \n \n 8.1 \n (有工具可以解決圖形衝突 ) \n 外部合併和差異工具 \n \n 您可以設置一個外部工具，來自動解決圖形衝突，而不必手動解決。 \n 強制視覺合併工具 " (P4Merge)  來執行差異和合併解析度 ,  因為它是一個不錯的圖形工具 ,  並且是免費的。 \n 8.2 \n Git 屬性資料還允許您在匯出專案存檔時執行一些有趣的操作。 \n \n 您可以告訴  Git  在生成存檔時不要匯出某些檔或目錄。如果有一個子目錄或檔不希望包含在存檔檔中 ,  但您確實希望簽入專案 ,  則可以通過export-ignore確定這些檔。 \n 例如 ,  假設您在test/子目錄中有一些測試檔案 ,  而將它們包含在專案的  tarball  匯出中是沒有意義的。您可以將以下行添加到  Git  屬性檔中 : \n test/ export-ignore \n 合併策略 \n 您還可以使用  Git  屬性告訴  Git  對專案中的特定檔使用不同的合併策略。一個非常有用的選擇是告訴  Git  不要嘗試合併特定的檔時 ,  他們有衝突 ,  而是使用你的一方合併超過別人的。 \n 如果專案中的分支存在分歧或是專用的 ,  但您希望能夠將更改合併回其中 ,  並且希望忽略某些檔 ,  這將很有説明。假設您有一個名為database.xml " 的資料庫設置檔 ,  該檔在兩個分支中是不同的 ,  並且您希望在不弄亂資料庫檔案的情況下合併到其他分支中。 \n 8.3 \n 整理 自訂 Git Hooks \n 教你一些鉤子的用法並告訴妳這些能尬麻 ?  使用鉤子來檢查提交消息是否符合所需的模式等等 ….. \n 前 4 種掛鉤與提交過程有關 \n 新興工作流程掛鉤 \n 電子郵件工作流程掛鉤 \n 其他用戶端掛鉤 \n 伺服器端掛鉤 \n \n \n 注意 :  此腳本無法停止推送過程 ,  但用戶端在完成之前不會斷開連接 ,  因此 ,  如果您嘗試執行任何可能需要很長時間的操作 ,  請務必小心。 \n 8.4 \n \n 本章要用你所學過的知識來建一個 git 工作流，並將構建用戶端腳本 ,  以説明開發人員知道他們的推送是否會被拒絕 ,  以及實際強制實施策略的伺服器腳本。 \n \n 7.2 \n 交互式暫存 運行git add時使用-i或者--interactive選項，Git將會進入一個交互式終端模式 $ git add -i 暫存與取消暫存文件 在如果What now>提示符後鍵入2或u，腳本將會提示想要暫存哪個文件 Update>> 1,2 \n 如果在Update>>提示符後不輸入任何東西並直接按回車，Git將會暫存之前選擇的文件 要取消暫存TODO文件，使用3或r（撤消）選項 \n 7.1 工具 - 選擇修訂版本 \n 如何獲取單個與區間提交的多種方法。 簡短的 SHA-1 Git 十分智能，你只需要提供SHA-1 的前幾個字符就可以獲得對應的那次提交，當然你提供的SHA-1 字符數量不得少於4 個，並且沒有歧義——也就是說，當前倉庫中只有一個對像以這段SHA-1 開頭。 假設這個提交是 1c002dd....，如果你想 git show 這個提交，下面的命令是等價的（假設簡短的版本沒有歧義）： $ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b $ git show 1c002dd4b536e7479f $ git show 1c002d 分支引用 你想要查看一個分支的最後一次提交的對象，假設 topic1 分支指ca82a6d ，那麼以下的命令是等價的: $ git show ca82a6dff817ec66f44342007202690a93763949 $ git show topic1 rev-parse 的 Git 探測工具 想知道某個分支指向哪個特定的 SHA-1，或者看任何一個例子中被簡寫的 SHA-1 引用日誌 你可以使用 git reflog 来查看引用日誌 查看你的master分支在昨天的時候指向了哪個提交 $ git show master@{yesterday} 運行可以git log -g來查看類似於git log輸出格式的引用日誌信息 祖先引用 你可以使用HEAD^來查看上一個提交，也就是“HEAD的父提交”： $ git show HEAD^ 後面添加一個數字 - 例如d921970^2代表“d921970的第二父提交”這個語法只適用於合併（merge）的提交 $ git show d921970^2 另一種指明祖先提交的方法是~，因此HEAD~和HEAD^是等價的 提交區間 $ git log master..experiment 查看在master分支中而不在experiment分支中的提交 $ git log experiment..master 多點  下列3個命令是等價的： $ git log refA..refB $ git log ^refA refB $ git log refB --not refA 所有被refA或refB包含的但是不被refC包含的提交 $ git log refA refB ^refC $ git log refA refB --not refC 三點 master或者experiment中所有遊戲的但不是兩者教育學習語言文字的提交 $ git log master...experiment \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'git.html'}, {'title': 'V-rep', 'text': 'Proximity sensor \n 添加 接近傳感 器  proximity sensor \n Menu bar --> Add --> Proximity sensor --> Cone type \n \n 在  orientation dialog  對話框中 \n 沿y軸和z軸旋轉90度 點擊Rotation Selection \n \n 在  position dialog  對話框中 \n x方向設置0.1 z方向設置0.12 \n \n 修改距離傳感器的參數Show volume parameter \n Offset    0.005,   Angle    30    Range    0.15 \n Show detection parameter中將Don’t allow detection ifdistance smaller than取消 \n 最後將傳感器連接到機器人的身體 \n \n Vision sensor \n 添加視覺傳感器  vision sensor \n Menu bar-->Add-->Vision sensor-->Perspective type \n 將視覺傳感器和距離傳感器放置一起且方向一致 \n 1. 在視覺傳感器的屬性欄中配置Far clipping plane 爲1 \n  Resolution x 和y 設爲256和256 \n 2. 點擊show filter dialog  \n \n 3. 選擇Edget detection on work image \n  然後點擊Add filter \n 4. 閾值設置爲0.2 點選OK \n \n Floating view上右鍵 View-->Associate simulation with selected vision sensor \n \n 就可以看到視覺感測器的畫面 \n \n bubbleRob腳本 \n 選擇對象BubbleRob--->右鍵選擇Add-->Associate child script-->Non threaded \n 腳本文件語言爲lua語言 \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n bubbleRob \n 成品圖 \n \n', 'tags': '', 'url': 'V-rep.html'}, {'title': 'Onshape', 'text': '手足球製作 \n 足球員 \n \n 場地 \n \n 手把 \n \n 組合圖 \n \n 40623118：製作手把與進行組合圖組裝 \n 40623141：製作手足球員與場地 \n 組合圖連結 \n', 'tags': '', 'url': 'Onshape.html'}, {'title': '問題與討論', 'text': '', 'tags': '', 'url': '問題與討論.html'}, {'title': 'ungit', 'text': '問題-無法取得使用者資料-已解決 \n 當使用ungit提交推送時，出現如下圖的錯誤內容 \n \n 解決方法: \n 至啟動隨身系統的start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n 使ungit能找到 y:\\home中的使用者目錄 \n', 'tags': '', 'url': 'ungit.html'}, {'title': 'ShareX', 'text': "遇到以下問題 \n ffmpeg version N-92972-g301cee61fa Copyright (c) 2000-2019 the FFmpeg developers  \n built with gcc 8.2.1 (GCC) 20181201  \n  configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-amf --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt  \n libavutil  56. 25.100 / 56. 25.100  \n libavcodec 58. 43.101 / 58. 43.101  \n libavformat 58. 25.100 / 58. 25.100  \n libavdevice 58. 6.101 / 58. 6.101  \n libavfilter 7. 48.100 / 7. 48.100 \n libswscale 5. 4.100 / 5. 4.100  \n libswresample 3. 4.100 / 3. 4.100  \n libpostproc 55. 4.100 / 55. 4.100  \n [gdigrab @ 00000298ebd8ca40] Capturing whole desktop as 1680x1050x32 at (0,0) [gdigrab @ 00000298ebd8ca40] Stream #0: not enough frames to estimate rate; consider increasing probesize Input #0, gdigrab, from 'desktop': Duration: N/A, start: 1554687275.611611, bitrate: 1693452 kb/s  \n Stream #0:0: Video: bmp, bgra, 1680x1050, 1693452 kb/s, 30 fps, 1000k tbr, 1000k tbn, 1000k tbc [dshow @ 00000298ebd90900] Could not enumerate audio only devices (or none found). [dshow @ 00000298ebd90900] Searching for audio device within video devices for 麥克風 (Realtek High Definition Au [dshow @ 00000298ebd90900] Could not enumerate audio only devices (or none found).  \n audio=麥克風 (Realtek High Definition Au: I/O error \n \n 解決辦法 \n google 搜尋 ShareX FFMPEG Error \n Task settings>Scren recorder>Screen recording options \n \n \n 按Install recorder devices來安裝，並在Audio source選擇None \n \n \n", 'tags': '', 'url': 'ShareX.html'}, {'title': '組員操作影片', 'text': '', 'tags': '', 'url': '組員操作影片.html'}, {'title': '如何製作可攜系統', 'text': '40623105 \n \n 40623109 \n \n 40623118 \n \n 40623141 \n \n 40623156 \n \n', 'tags': '', 'url': '如何製作可攜系統.html'}, {'title': 'v-rep tutorial', 'text': '40623105 \n \n 40623109 \n \n 操作檔案： bubbleRob.ttt \n 40623118 \n \n 40623127 \n \n 40623135 \n \n', 'tags': '', 'url': 'v-rep tutorial.html'}, {'title': '配置虛擬主機', 'text': '40623156 \n \n', 'tags': '', 'url': '配置虛擬主機.html'}, {'title': 'Git教材', 'text': '', 'tags': '', 'url': 'Git教材.html'}, {'title': '伺服器上的Git', 'text': 'Git可以使用四種主要協議來傳輸數據： \n Local protocols、HTTP、Secure Shell（SSH）和Git。 \n 通過上方多種方式啟動並運行遠程Git存儲庫，以便您可以與其他人協作或共享您的工作。 \n 運行自己的服務器可以為您提供很多控制，並允許您在自己的防火牆內運行服務器，但是這樣的服務器通常需要相當多的時間來設置和維護。 \n 通訊協定種類 \n \n Local protocols \n 優點: \n 1.可以直接將存儲庫副本粘貼到每個人都具有共享存取權限的位置，並像設置任何其他共享目錄一樣設置讀/寫權限。 \n 2.運用這些指令(git pull /home/john/project等) ，通常會更簡單地使他們推送到遠端，並且您也方便拉取。 缺點: \n 1.共享存取通常更難以從多個位置進行設置和存取。 \n 2.若在家使用筆電的話，需額外安裝遠端系統，否則會相對於基本網路存取還要來得困難與慢上許多。 \n 3.每個用戶都具有對“遠程”目錄的完全要訪問權限，並且沒有任何東西阻止他們更改或刪除內部Git文件並破壞存儲庫。 \n SSH通訊協定( Secure Shell ) \n 優點: \n 1.SSH相對容易設置，且它的守護程序很常見。 \n 2.透過SSH存取是安全的，所有數據傳輸都經過加密和身份驗證。 \n 3.像HTTP/S、Git與Local protocols一樣，使數據在傳輸之前盡可能緊湊。 \n 缺點: \n 1.無法通過它對存儲庫進行匿名存取。 \n 2.如果想允許匿名存取項目並且還想使用SSH，則必須設置SSH以便推送，但其他內容可供其他人獲取。 \n Git協定 \n 優點: \n 1.為最快的網絡傳輸協議。 \n 2.若為公共項目提供大量流量或為不需要用戶身份驗證進行讀取的大型項，則可能需要設置Git守護程序。 \n 3.Git存儲庫可供所有人克隆。 \n 缺點: \n 1.缺乏身份驗證。 \n 2.通常為唯一存取權限(即推送、寫入等)，若開啟推送存取權限，則網路上能到找到項目的URL並任何人可推送到項目裡。 \n HTTP \n 可分為兩種，分別為新制(智能)與舊制。 \n 新制(智能): \n 與SSH或Git協定的運行方式非常相似，它可以設置為像git://協議一樣匿名服務，也可以通過SSH協議等身份驗證和加密來推送。 \n 舊制: \n 直接將Git存儲庫提供為來自Web服務器的普通文件，優點在於設置它的簡單性。此外，任何可以訪問放置存儲庫的Web服務器的人都可以存取您的存儲庫。 \n 以下優缺點於新制(智能)HTTP \n 優點: \n 1.能夠使用用戶名和密碼進行身份驗證。 \n 2.通過HTTPS以只讀方式提供存儲庫。 \n 缺點: \n 與某些服務器上的SSH相比，在HTTP/S上使用Git可能會有點棘手。 \n \n \n \n \n 在伺服器上佈署Git \n 要clone存儲庫以創建新的存儲庫，請使用該--bare選項運行clone命令。將存儲庫目錄結束.git。如下: \n $ git clone --bare my_project my_project.git \n 現在應該在目錄中擁有Git目錄數據的副本my_project.git。 \n 下面指令相當於類似的東西，但配置文件中存在一些細微差別。 \n $ cp -Rf my_project/.git my_project.git \n 將存儲庫複製到以下來設置新存儲庫： \n 假設/srv/git存在於該服務器上，並且已經設置了一個名為git.example.com的SSH服務器，而希望將所有Git存儲庫存儲在該/srv/git目錄下。 \n $ scp -r my_project.git user@git.example.com:/srv/git \n 之後，對於有這目錄及SSH的權限的用戶就可以來clone，也有推送訪問權限。 \n $ git clone user@git.example.com:/srv/git/my_project.git \n 如果git init使用該--shared選項運行命令，Git將自動將組寫入權限正確添加到存儲庫。 \n $ ssh user@git.example.com $ cd /srv/git/my_project.git $ git init --bare --shared \n \n 產生個人的SSH公鑰 \n 在該目錄並列出內容來輕鬆檢查是否已有密鑰。 輸入指令後有出現文件為id_dsa(id_rsa)為自己私人的密鑰，而文件後方多了.pub則為公鑰。如下: ~/.ssh為目錄 \n $ cd ~/.ssh \n $ ls \n authorized_keys2 \n id_dsa \n known_hosts \n config \n id_dsa.pub \n 如沒有密鑰時，可輸入下列指令來創建。 \n $ ssh-keygen \n 之後，會需要確保密鑰（.ssh/id_rsa）的位置，需輸入兩次密碼，不需要則可空白。 \n 如用戶需要複製有公鑰文件的內容，輸入下列指令。 ~/.ssh/id_rsa為公鑰位置 \n $ cat ~/.ssh/id_rsa.pub \n 伺服器的設定 \n 如要設置SSH存取的服務端，則需使用下列方式來進行身分驗證。 \n **git為用戶名、 .ssh為目錄、authorized_keys為驗證** \n $ sudo adduser git \n $ su git \n $ cd \n $ mkdir .ssh && chmod 700 .ssh \n $ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys \n 如需要為該用戶的文件添加一些開發人員的SSH公鑰，並將其保存到臨時文件中。如下: \n **john為開發人員的SSH公鑰** \n $ cat /tmp/id_rsa.john.pub \n 在一個沒有工作目錄的情況下設置一個空儲存庫。 \n $ cd /opt/git \n $ mkdir project.git \n $ cd project.git \n $ git init --bare \n 將文件推送至遠端儲存庫。 \n **myproject為文件** \n Git常駐程式 \n 如不想將大量的項目或人員都添加SSH密鑰時，以守護進程的方式運行下列指令: 此方法雖然設置方便而快速，但因沒有密鑰的身分驗證，所以任何人都可以存取裡面的內容。多用於世界性的公開項目。 \n $ git daemon --reuseaddr --base-path=/opt/git/ /opt/git/ \n --reuseaddr是允許服務器重新啟動而無需等待舊連接超時 \n --base-path是允許人們克隆項目而不指定整個路徑 \n **最後的路徑需告訴Git守護程序在哪裡查找要導出的存儲庫** \n 如果你正在運行防火牆，你還需要在你正在設置它的盒子上的端口9418處打一個洞。 但建議將此守護程序作為具有存儲庫的唯讀權限的用戶運行。 \n 在Ubuntu計算機上，您可以使用Upstart的腳本，並在文件中放入腳本。 \n **文件為/etc/init/local-git-daemon.conf** \n 腳本: \n start on startup \n stop on shutdown \n exec /usr/bin/git daemon \\ \n --user=git --group=git \\ \n --reuseaddr \\ \n --base-path=/opt/git/ \\ \n /opt/git/ \n respawn \n 要在不重新啟動的情況下運行計算機時 \n $ initctl start local-git-daemon \n 允許未經身份驗證的用戶存取指定的儲存庫。 \n $ cd /path/to/project.git \n $ touch git-daemon-export-ok \n', 'tags': '', 'url': '伺服器上的Git.html'}, {'title': '分散式的Git', 'text': '對Git中的項目做出貢獻以及維護自己的項目或整合其他用戶的貢獻 \n 分散式工作流程 \n 分散式工作流程分為三種 \n 集中式工作流程、整合式管理員工作流程、企業型工作流程 \n \n 集中式工作流程 \n 如前者有人推送，後者必須合併前者的版本，不然會無法推送至儲存庫，是因為避免前者的資料被覆蓋。 \n \n 整合式管理員工作流程 \n 項目維護者=A、開發人員=B \n A推送到他們的公共儲存庫。 \n B克隆該存儲庫並進行更改，並推動他們自己的公共副本。 \n B向A發送一封電子郵件，要求A提取更改。 \n A將B的repo添加為遠程，合併原先的資料，推送到主儲存庫。 \n \n 企業型工作流程 \n 老闆=A、副手=B、開發人員=C \n 正常的C會在他們主題的分支上工作，並在重新定義他們在master上的工作。而master分支是獨裁者的分支。 \n B將C的主題分支合併到B的master分支中。 \n A將B的master分支合併到A的master分支中。 \n A將他們推master送到參考存儲庫，以便其他C可以對其進行重新定義。 \n 分散式的 Git - 對專案進行貢獻 \n 對專案進行貢獻 \n 兩人合作圖 \n \n 兩人以上合作圖 \n \n', 'tags': '', 'url': '分散式的Git.html'}, {'title': 'Fork', 'text': '如果你想參與一個你沒有推送權限的專案，你可以「fork」一份。 \n 這代表說 GitHub會複製一份這個專案的副本給你， 並且你對這副本有全部的權限。 \n 這副本會存在於你的帳號下，你可以對它進行推送。如下 \n 紅色為原作者與原專案，綠色為Fork按鍵 \n \n 按下之後，專案會顯示在自己的底下。 \n \n 之後原專案的Fork會顯示如下 \n \n 先將所Fork到的專案clone下來，新建一個版本後，再回推回去。 \n 這時自己所Fork的專案要回推至原專案時，需要給原作者發送請求，方法如下 \n 到原專案的右方案 \n pull request > New pull resquest > compare across forks > 在base fork選原專案的master至head fork選自己專案master > 最後按下 Click to create a pull request for this comparison ，這樣就建立起一個pull request了。 \n 最後，我們先看一下右上角有個Able to merge的地方，會預先告訴你合併的結果，顯示你的版本跟原版本是否有衝突發生。 \n 如果都沒問題，可以再輸入一些說明文字給原作者，並按下 Send pull request 即可建立完成。 \n 管理 Pull Requests方面，可能是來自某個 fork 裡的分支， 或是同個倉儲裡的某個分支。而接收到時，會以電郵(信箱)通知。 \n 觀看所接受到的pull resquest沒問題後，按下 Merge pull request 即可完成合併工作。 \n', 'tags': '', 'url': 'Fork.html'}, {'title': 'ungit 手冊', 'text': '', 'tags': '', 'url': 'ungit 手冊.html'}, {'title': 'part1', 'text': '開啟 \n 1.首先打開隨身碟命令提示字元，進入tmp下的組別資料夾，打 kungit \n \n 2.下圖為 ungit 開啟後的版面 \n \n Fetch from origin \n 取得遠端資訊(Fetch from origin)：可以從近端查看想關注之遠端的資訊 \n ◎ origin : 為原本遠端的 github 網址 \n \n ◎取得想關注的遠端資料(add new remote) \n \n (1)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (2)送出後，再點選想要查看的網址名稱 \n \n (3)以下為點開後的圖面 \n \n 子模組Submodules \n 子模組 ( submodules)  : 在資料夾內抓取另一個遠端資料夾內容並新增修改 \n \n ◎新增子模組 (add submodules) \n \n (1)取得想新增的子模組 \n \n (2)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (3)點選上傳子模組(update submodules) \n \n (4)點選想要新增的子模組 \n \n (5)以下為新增的子模組資料 \n \n (6)資料夾內也會顯示新增的資料夾 \n \n 分支Branch \n  1.切換分支：點選想要切換的分支即可 \n  2.刪除 分支：點選 x 即可刪除 \n ↓1.及2.皆是以下圖來進行操作 \n \n  3.add Branch (新增分支)  \n (1) 點下圖中的圖形即可新增分支或標籤 \n \n (2) 打上名稱(此處以新增 branch 為範例) \n \n (3) 會顯示 aaa 分支 \n \n 4. checkout branch (切換分支) \n 依序下圖進行操作就可以切換分支 \n ↓按下aaa，再點選check out \n \n ↓完成後，即可切換分支 \n \n 5.delete branch (刪除分支) \n \n (1)刪除此 aaa 分支或標籤，讓其進行還原 \n \n (2)下圖為還原後顯示的畫面 \n \n 忽略內容 \n 忽略內容   .gitignore \n \n → 點擊後顯示的內容 \n \n 以下示範 : \n (1)*.a → 將字尾為 .a 的文件都忽略 \n a. 選擇忽略以.txt為結尾的文件 (附檔名可自行選擇) \n \n b. 將 .gitignore 用 scite 開啟 \n \n c. 在 .gitignore 內新增下圖文字 \n \n d. 修改後 .gitignore 會顯示其內容 \n \n e. .txt的文件已被忽略(如下圖) \n \n (2) !*lib.a → 將字尾為 .a 的文件都忽略但 lib.a 除外 \n a. 以下要示範忽略 .txt 的文件但 456.txt保留 \n  (附檔名可自行選擇；不忽略檔案也可自行選擇) \n ↓下圖為2個檔案都存在 \n \n b. 在 .gitignore 內新增下圖文字 \n \n c. 檔案以忽略除了456.txt的文件 \n \n', 'tags': '', 'url': 'part1.html'}, {'title': 'part2', 'text': '提交Commit \n 1. Create an empty commit (新增提交) \n 依序下圖步驟操作即可新增提交 \n \n \n \n \n ↓完成後會顯示，如下圖 \n \n 2. Amend previous commit (修改上一個提交) \n \n \n \n ↓完成會顯示，如下圖 \n \n 3.uncommit (不提交) \n \n 下為按下 uncommit 後的圖面 \n \n 從這開始就有不同的步驟去刪除多餘的提交 \n (1) 用 Move 使其刪除 \n →將藍色origin/master拖曳至move \n \n a. \n \n b. \n \n c. \n \n d. \n \n (2) 利用 push 推回 \n \n → 按下 push 後也會產生出 a. b. c. d. 圖 \n Tag \n add Tag (新增標籤) \n 標籤是對某個 commit 的指標，類似於分支，標籤可分兩種： \n ◎輕量標籤 (lightweight tag)：是指對某個 commit 的指標，沒有包含其他附註資訊，用來個人使用或暫時標註。 \n ◎有附註標籤(annotated tag)：類似於輕量標籤，只是能多附註關於此張標籤的說明及資訊，用於軟體版號等。 \n 新增及刪除標籤步驟跟 branch 相同，在此會用圖說明標籤與分支的不同 \n (1) 在 commit "test tag-1" 上新增 "說明標籤與分支的不同" 的標籤 \n \n (2) 新增後 \n \n (3) 提交一個 "test tag-2" 的 commit ，分支 aaa 移至新的提交位置上，而標籤 " 說明標籤與分支的不同 " 停留於原處。 \n \n Megre (合併) \n \n \n \n Move (移動) \n 可用來移動分支，範例如下 \n (1) 點分支 master \n \n (2) 按下 Move \n \n (3) 詢問是否移動此分支(這個行動有在歷史上出現過) \n \n (4) 下為移動後的圖面 \n \n Cherry pick \n Cherry pick (撿取某分支的 commit 來合併，但不是全部的 commit ) \n (1) 下圖中游標所在位置是想要合併的 commit ，點它 \n \n (2)按下 Cherry pick \n \n (3) master所在位置為撿取的 commit \n \n \n Revert (還原) \n 再做一個 新 commit ，來取消不要的 commit，原本的 commit 還是會存留在歷史紀錄中。 \n 適合在多人共同協作的專案中，使用 Revert 對於其他協同者來說不算是 修改歷史 ，而是增加一個新的 commit 。 \n (1) 在資料夾中新增 2.txt \n \n (2) 進行 commit and push \n \n (3) 點選要進行 revert 的 commit \n \n (4) 點 revert \n \n (5) 會顯示出 Rvert "test revert"，此項新 commit \n \n (6) 資料夾中的 2.txt 會消失，讓整個資料夾還原 \n \n Reset (重新) \n 直接刪除不要的 commit (會讓歷史中的紀錄改變)，常用在未推交的 commit ，適用於個人的專案。 \n (1) 進行 commit \n \n (2) 點游標所在處 \n \n (3) 按 Reset \n \n \n \n Rebase (重新定義參考基準) \n 重新定義某分支的參考基準。每一個 commit 都能增加分支，而分支的基準就是產生出此分支的 commit ，rebase 是能把產生出該分支的 commit 改到另一個 commit ，但是使用 rebase 會影響到 commit 原有的先後關係，所以操作時要多加注意。在此使用範例去解說： \n (1) 利用 scite 建立一個 test rebase.htm ，內容如下圖並另存至資料夾。 \n \n (2) 在分支 master 上進行提交 \n <img caption="false" height="313" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABPsAAAINCAYAAABI/3oJAAAgAElEQVR4Xuy9B3hU15n//1XvHSFQQYAkhADRezXFDWOMS7Adt2Rjm3izBWc33mw2/jlZJ/lnk93Y3t1sYsdJ1m0dk9hxAAPGGDCY3juogQSSaOqot//zntEdzYzuVM1IM9L3PMljNHPvKZ9zR6CP3ve8flnZ0zqh1/wAaO+Y/ln34q4XXblHbpX7LJv+rGyNzvdIgARIgARIgARIgARIgARIgARIgARIgARIYFAT8Msaa0X2DWosXDwJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJ+B4Byj7f2zPOmARIgARIgARIgARIgARIgARIgARIgARIgAR0CVD28cEgARIgARIgARIgARIgARIgARIgARIgARIggQFCwC9r7NSu0/EsD+az97UQ0DvMT+/gPmuH/jl6GOAAoc1lkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIAHCfhlGmWfvrqTV/3QaazVoT8XrcJGp67+603PHlw7uyYBEiABEiABEiABEiABEiABEiABEiABEiCBAUXAz1iN15ngO3cG5LmzrwG1NVwMCZAACZAACZAACZAACZAACZAACZAACZAACThHoCuyr2f0XreD647a07rWS/CV97rygS2i+2ylAzsSNejcgng1CZAACZAACZAACZAACZAACZAACZDAwCQQ8vVfDMyFcVUk4EYCflnZ2pl9Vno1c309w/DCAgKQEBSEQD8/BPhpF7txhuyKBEiABEiABEiABEiABEiABEiABEiABABcfuRHOP3CIrIgARKwQcAvc+y0TkNMnn4+bc9XDa9ITF58UCDig4LgR8nHh4wESIAESIAESIAESIAESIAESIAESMDDBIpXv0zZ52HG7N73CfhlZk/t1IRej6RaY1SfH+CnOUHDVeH+ARgRFur7BLgCEiABEiABEiABEiABEiABEiABEiABnyBQRNnnE/vESfYvASX7zKYgUXpdr5hX4TWP8RsREorIoMD+nT1HJwESIAESIAESIAESIAESIAESIAESGDQEClf/KyP7Bs1uc6GuEjAU6DDG9nUl85p5va6oPhnBqAX9kBMRhkB/f1fH5X0kQAIkQAIkQAIkQAIkQAIkQAIkQAIk4BSBvK9Q9jkFjBcPSgJ+WWOndpqH9ply0D/HT5Tg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 \n ======= >>>>>>> 79fa8cb90d3c3fffed068f0eac93ae7771cff48b', 'tags': '', 'url': 'part2.html'}]};